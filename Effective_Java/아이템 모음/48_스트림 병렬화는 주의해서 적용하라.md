# 7장. 람다와 스트림(p253~296)

> 자바 8에서 **함수형 인터페이스, 람다, 메서드 참조**가 추가되면서 함수 객체를 더 쉽게 만들 수 있게 되었다. 이와 함께 **스트림 API**까지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다. 
>
> 이번 장에서는 이 기능들을 효과적으로 사용하는 방법을 알아보려 한다.

## 아이템 48. 스트림 병렬화는 주의해서 적용하라(p291~296)

이번 아이템의 결론은 간단하다. parallel 메서드를 사용하여 스트림 파이프라인을 마구잡이로 병렬화하면 안 된다. 성능이 끔찍하게 나빠질 수도 있다. 특히 **데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.**

아래는 아이템 45에서 다룬 메르센 소수를 생성하는 프로그램으로, 책의 저자의 컴퓨터에서 실행했을 때 12.5초만에 완료되었다고 한다. 하지만 여기에서 속도를 더 높이겠다고 해서 parallel()을  호출해서는 안 된다. 이 경우 데이터 소스가 Stream.iterate에서 나오고, 중간 연산으로 limit을 사용하기 때문이다.

```java
public static void main(String[] args) {
	primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
			.filter(mersenne -> mersenne.isProbablePrime(50))
			.limit(20)
			.forEach(System.out::println);
}

static Stream<BigInteger primes() {
		return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

대체로 스트림의 소스가 **ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.**

> 이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기에 좋다는 특징이 있다.
>
> 나누는 작업은 Spliterator가 담당하며, Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있다.

다량의 데이터를 처리하는 벌크 연산을 병렬화하는 경우 **참조 지역성**(locality of reference)이 매우 중요하다. 원소의 참조들이 메모리에 연속해서 저장되어 있을 때 스레드가 효율적으로 일할 수 있다. 참조 지역성이 낮으면 스레드는 그저 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 있어야 한다. 참조 지역성이 가장 뛰어난 자료구조는 기본 타입 배열이며, 배열로 구현한 인스턴스도 괜찮다.

스트림 파이프라인에서 종단 연산의 동작 방식도 병렬 수행 효율에 영향을 준다. 종단 연산의 작업량이 꽤 큰 순차적인 연산이라면 병렬 수행의 효과가 제한된다.

> 종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)다. 
>
> 축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업으로, Stream의 **reduce** 메서드 중 하나, 혹은 **min, max, count, sum** 같이 완성된 형태로 제공되는 메서드 중 하나를 선택해 수행한다. **anyMatch, allMatch, noneMatch**처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다.
>
> 반면, 가변 축소(mutable reduction)를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.

고효율의 스트림 병렬화 작업을 구현하기란 쉽지 않다. 꼭 알아두어야 할 점이 있다면, **스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 예상 못한 동작(응답 불가, 잘못된 결과 등) 문제가 발생할 수 있다.**

스트림 병렬화는 지극히 성능 최적화를 위해서만 사용해야 하며, 반드시 성능을 테스트해봐야 한다(아이템 67). 보통 병렬 스트림 파이프라인은 같은 스레드 풀을 사용하므로, 잘못된 파이프라인 하나가 시스템의 다른 부분에까지 악영향을 줄 수 있다.

물론 **parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상 효과를 볼 수도 있다.** 하지만 현업에서 병렬화를 사용할 일은 많지 않다.

> 책에서는 스트림 파이프라인 병렬화로 효과를 볼 수 있는 간단한 예를 소개하고 있다. p295에서 pi(n) 메서드의 구현을 참고하자. 해당 예제는 실무에서 쓸 일이 거의 없고, 더 나은 알고리즘이 이미 존재하기 때문에 따로 정리하지 않았다.

## 마무리

- 정해진 답은 간단하다. 계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라.

