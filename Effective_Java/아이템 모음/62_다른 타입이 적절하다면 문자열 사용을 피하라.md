# 9장. 일반적인 프로그래밍 원칙(p343~384)

> 이번 장에서는 자바 언어의 핵심 요소라고 할 수 있는 다음 내용들을 다룬다.
>
> - 지역변수
> - 제어구조
> - 라이브러리
> - 데이터 타입 
> - 리플렉션과(언어 경계를 넘나드는 기능) 
> - 네이티브 메서드
> - 최적화와 명명 규칙

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라(p362~365)

## 문자열을 쓰지 말아야 할 사례

- **사례 1**: **문자열은 다른 값 타입을 대신하기에 적합하지 않다.** 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 문자열을 사용하는 경우가 많다. 하지만 이는 적합하지 않다. 입력받을 데이터가 진짜 문자열일 때만 문자열 타입을 사용하자.만약 수치형를 받는 경우라면 int, float, BigInteger 등 적당한 수치 타입으로 변환하자. 그리고 '예/아니오' 질문의 대답을 받는다면 열거 타입이나 boolean으로 변환하자. 

- **사례 2**: **문자열은 열거 타입을 대신하기에 적합하지 않다.** 상수를 열거할 때는 문자열보다는 열거 타입이 월등히 낫다(아이템 34 참고).

- **사례 3**: **문자열은 혼합 타입을 대신하기에 적합하지 않다.** 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 좋지 않다. 다음 예를 보자.

  ```java
  String compoundKey = className + "#" + i.next();
  ```

  이렇게 혼합 타입을 사용하는 경우, 각 요소에 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커진다. 그래서 차라리 전용 클래스를 새로 만드는 편이 낫다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다(아이템 24).

- **사례 4**: **문자열은 권한(capacity)을 표현하기에 적합하지 않다.** 예를 들어 스레드 지역변수 기능을 설계한다고 하자.

  ```java
  public class ThreadLocal {
    private ThreadLocal() { } // 객체 생성 불가
    	// 현 스레드의 값을 키로 구분해 저장한다.
    	public static void set(String key, Object value);
    
    	// (키가 가리키는) 현 스레드의 값을 반환한다.
    	public static Object get(String key);
  }
  ```

  위의 코드에 따르면, 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별한다. 이 방식의 문제는 스레드 구분용 문자열 키가 전역 이름공간에서 공유된다는 것이다. 만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰게 되면, 두 클라이언트 모두 제대로 기능하지 못하게 된다. 

  이를 대신해, Key 클래스로 권한을 구분하는 방법을 선택할 수 있다.

  ```java
  public class ThreadLocal {
    private ThreadLocal() { } // 객체 생성 불가
    
    public static class Key { // (권한)
      Key() { }
    }
    
    // 위조 불가능한 고유 키를 생성한다.
    public static Key getKey() {
      return new Key();
    }
    
    public static void set(Key key, Object value);
    public static Object get(Key key);
  }
  ```

  여기에서 조금 더 개선해보자면, set과 get을 정적 메서드로 두지 않고, Key 클래스의 인스턴스 메서드로 바꾸어보자. 그러면 Key의 역할 자체가 스레드 지역변수가 되어 Key 이름 대신 ThreadLocal 로서 선언 및 사용이 가능하다. 마지막으로 Object 타입으로 받는 부분을 매개변수화 타입으로 변경하면 결과적으로 다음 코드처럼 리팩터링하여 사용할 수 있다.

  ```java
  public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
  }
  ```

  위 방법은 문자열 기반 API 문제를 해결하고, Key 기반 API 보다 좋은 성능을 가진다.

## 마무리

- 더 적합한 데이터 타입이 있거나 새로 작성할 수 있는 변수라면 문자열 사용을 피하자. 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다. 
- 문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입 등이 있다.


