# 8장. 메서드(p297~342)

> 이번 장에서는 **메서드를 설계할 때 주의할 점**들을 살펴본다. 
>
> - **매개변수**와 **반환값**을 어떻게 처리해야 하는지
> - **메서드 시그니처**는 어떻게 설계해야 하는지
> - **문서화**는 어떻게 해야 하는지를 다룬다. 
> - 이번 장의 내용 중 상당 부분은 메서드뿐 아니라 **생성자**에도 적용된다. 

## 아이템 53. 가변인수는 신중히 사용하라(p320~322)

> 가변인수(varargs) 메서드는 **명시한 타입의 인수를 0개 이상 받을 수 있다.** 
>
> 가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 **인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.** 인수 개수는 런타임에 (자동 생성된) 배열의 길이로 알 수 있다.

다음은 가변인수를 사용하는 sum 메서드 예제다. sum(1, 2, 3)은 6을, sum()은 0을 돌려준다.

```java
static int sum(int... args) {
    int sum = 0;
    for (int arg : args)
        sum += arg
    return sum; ;
}
```

인수가 최소 1개 이상 필요할 때는 가변인수를 어떻게 활용할 수 있을까? 예를 들어 인수들의 최솟값을 구하기 위해 다음과 같이 코드를 작성할 수 있다.

```java
static int min(int firstArg, int... remainingArgs) {
  int min = firstArg;
  for (int arg : remainingArgs) {
    if (arg < min) {
      min = arg;
    }
  }
  return min;
}
```

한편, 가변인수 메서드는 호출될 때마다 배열을 새로 만들고 이를 초기화한다. 배열 생성 비용이나 사용성, 성능을 고려할 때 가변인수 처리는 항상 좋은 선택이 아니다. 때로는 고정된 개수의 인수를 받는 것이 더 나을 수 있다. 예를 들어 3개 이하로 인수를 받아 사용하는 메서드 사용률이 95% 이상이라면, 아래와 같이 메서드를 선언하는 것이 더 낫다.

```java
public void foo() { }
public void foo(int al) { }
public void foo(int al, int a2) { }
public void foo(int al, int az, int a3) { }
public void foo(int al, int az, int az, int... rest) { }
```

대표적으로, EnumSet의 정적 팩터리도 이 기법을 사용하여 열거 타입 집합 생성 비용을 최소화한다.

## 마무리

- 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다. 
- 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.


