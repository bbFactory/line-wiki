# 4장. 클래스와 인터페이스(p95~152)

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라(p122~129)

 프로그래머는 '외부' 클래스를 상속할 때의 위험을 인지하고 있어야 한다. 여기에서 **'외부'란 프로그래머의 통제권 밖에 있어서 언제 어떻게 변경될지 모르는 곳**이라는 뜻이다. '외부'의 변동 위험에서 안전하기 위해서는 **상속을 고려한 설계와 문서화**가 필요하다.

## 상속을 고려한 설계와 문서화

**상속용 클래스라면 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨 놓아야 한다.** 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리해야 한다.

공개된 API 메서드에서 클래스의 또 다른 메서드를 호출할 수도 있다. 그런데 마침 호출되는 메서드가 '재정의 가능'하다면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. '재정의 가능'이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 뜻한다.

API 문서의 메서드 설명 끝에 있는 **"Implementation Requirements"** 절은 **메서드의 내부 동작 방식을 설명하는 곳**이다. 이 절은 메서드 주석에 **@implSpec** 태그를 달면 자바독 도구가 생성해준다. 다음은 java.util.AbstractCollection에서 발췌한 예다.

> public boolean remove(Object e)
>
> 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 'Object.equals(o, e)가 참인 원소' e가 하나 이상 있따====다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면(즉, 호출 결과 이 컬렉션이 변경됐다면) true를 반환한다.
>
> **Implementation Requirements**: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 찾고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.

이러한 설명은 remove 메서드 호출시 동작하는 iterator 메서드를 재정의할 때, 어떤 부분을 주의해야 하는지, 어떤 경우에 오류가 발생하는지 짐작할 수 있게 해준다.

## @implSpec 태그

@implSpec 태그는 자바 8에서 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했다. 이 태그를 활성화하기 위해 명령줄 매개변수로 `-tag "implSpec:a:Implementation Requirements:"`를 지정해주면 된다.

## 올바른 상속 설계를 위한 노하우

protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 적을수록 좋다. 하지만 너무 적게 노출하는 것은 상속으로 얻는 이점을 없앤다. 

**상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다**. 대략 3개 정도의 하위 클래스를 만들어 사용해보자. protected여야 하는 멤버인데 private으로 설정했다면 하위 클래스 작성 시 빈자리가 확 느껴진다. 반대로 여러 개의 하위 클래스를 만들었지만 사용되지 않은 protected 멤버가 있다면 private으로 바꿔주자. **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.**

## 상속 설계 시 고려해야 할 제약

**상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.** 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되기 때문에 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 

아래 Super 클래스의 생성자가 실제로 자신의 하위 클래스인 Sub 클래스의 생성자보다 먼저 실행되는 것을 볼 수 있다.

```java
public class Super {
    // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
    public Super() {
        System.out.println("1234");
        overrideMe();
    }

    public void overrideMe() {
    }
}
```

```java
public final class Sub extends Super {
    // 초기화되지 않은 final 필드. 생성자에서 초기화된다.
    private final Instant instant;
    
    Sub() {
        System.out.println("789");
        instant = Instant.now();
    }
    
    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override
    public void overrideMe() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

아래는 main 메서드를 실행한 결과이다.

```java
1234
null
789
2021-09-21T13:39:52.974Z
```

출력 결과에서 null은 어떻게 나오게 된 걸까? 상위 클래스 Super의 생성자는 하위 클래스 Sub의 생성자가 인스턴스 필드를 초기화하기도 전에 override를 호출한다. 

한편, Cloneable과 Serializable 인터페이스 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다. clone과 readObject 메서드를 정의할 때도 주의해야 한다. **두 메서드 모두 생성자와 비슷한 효과(새로운 객체를 만드는 효과)를 내기 때문에 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안 된다.** 복제본을 만들기 전에 또는 역직렬화를 마치기 전에 재정의한 메서드를 호출해서는 안 되기 때문이다.

마지막으로, Serializable을 구현한 상속용 클래스의 readResolve나 writeReplace 메서드는 private이 아닌 protected로 선언해야 한다.

## 상속용이 아닌 구체 클래스

final도 아니고 상속용으로 설계되거나 문서화되지도 않은 구체 클래스를 그대로 두는 것은 위험하다. 클래스의 내부 변경에 따라 하위 클래스에서 문제가 발생할 수 있기 때문이다.

**가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하게 만드는 것이다.** 상속을 금지하는 방법은 두 가지다. 

1. **클래스를 final로 선언한다.**
2. **모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만든다.**

번외로, 클래스가 핵심 기능을 가지고 있어야 한다면 굳이 상속이 아니더라도 **핵심 기능을 정의한 인터페이스**를 사용할 수 있다. Set, List, Map이 좋은 예다. 다른 하나는 **래퍼 클래스 패턴**(아이템 18)으로, 이 역시 기능을 증강할 때 상속 대신 쓸 수 있는 더 나은 방법이다. 마지막으로 상속은 허용하되 애초에 재정의 가능 메서드를 사용하지 못하게 만드는 방법도 있다.


