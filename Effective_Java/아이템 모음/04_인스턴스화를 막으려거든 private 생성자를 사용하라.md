# 2장. 객체 생성과 파괴(p7~94)

## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라(p26~27)

**인스턴스를 생성하지 않고** 멤버들을 사용하기 위해 클래스를 정의하는 경우가 있다. 대표적으로 정적 멤버만을 담고 있는 **유틸리티 클래스**와 **추상 클래스**가 있다(참고로 유틸리티 클래스는 `java.lang.Math` 또는 `java.util.Arrays` 와 같은 것들이다).

유틸리티 클래스는 **정적 멤버**의 사용을 목적으로 설계된 것이다.  굳이 인스턴스를 만들어 사용하는 것은 클래스 설계 목적에 부합하지 않는다. 

하지만 유틸리티 클래스 내부에 어떠한 생성자도 명시하지 않을 경우 컴파일러는 자동으로 기본 생성자를 만든다. 이 생성자를 통해 어느 누군가는 설계 의도와 달리 유틸리티 클래스의 인스턴스를 생성하여 사용할 수 있다. 설계자는 이와 같은 경우를 대비해 인스턴스의 생성을 막고 싶을 것이다. 

추상 클래스 역시 원하지는 않지만 인스턴스로 만들어 사용할 수 있다. 하위 클래스를 만들어 인스턴스를 생성하면 그만이다. 사용자의 입장에서는 상속해서 쓰라는 뜻으로 오해할 수 있으니 더 큰 문제다.

그렇다면, 클래스의 인스턴스화를 원하지 않는 경우 어떻게 해야 할까?

방법은 간단하다. 클래스의 인스턴스화를 막기 위해서 **private 생성자를 정의하면 된다.**

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    ... // 나머지 코드는 생략
}
```

private 생성자가 명시되어 있으니 컴파일러는 다른 어떤 생성자도 만들어내지 않는다. 유일한 생성자인 private 생성자를 외부에서는 접근할 수 없으니 `UtilityClass`의 인스턴스를 만드는 것은 불가능하다.

> 생성자 블록 안에서 반드시 AssertionError를 던질 필요는 없다. 하지만 이는 클래스 안에서 생성자를 호출하는 실수를 방지한다.

추가적으로 private 생성자 사용의 이점을 요약하면 다음과 같다.

## private 생성자 사용의 이점

- **어떠한 환경에서도 클래스가 인스턴스화되는 것을 막는다.** 
-  private 생성자 선언으로 **상속을 막는다.**

> 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데, 이를 private으로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버린다.
