# 7장. 람다와 스트림(p253~296)

> 자바 8에서 **함수형 인터페이스, 람다, 메서드 참조**가 추가되면서 **함수 객체**를 더 쉽게 만들 수 있게 되었다. 이와 함께 **스트림 API**까지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다. 
>
> 이번 장에서는 이 기능들을 효과적으로 사용하는 방법을 알아보려 한다.

## 아이템 45. 스트림은 주의해서 사용하라(p268~276)

## 스트림의 핵심 추상 개념

스트림 API는 **다량의 데이터 처리 작업**(순차적이든 병렬적이든)을 돕기 위해 자바 8에 추가되었다. 이 API는 두 가지 핵심 추상 개념을 제공한다.

- **스트림(stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 뜻하는 개념** 이다.
- **스트림 파이프라인(stream pipeline)은 이 원소들로 수행하는 연산 단계를 표현하는 개념** 이다.

## 스트림의 특징

- 스트림의 원소는 컬렉션, 배열, 파일, 정규표현식 패턴 매처(matcher), 난수 생성기, 다른 스트림 등 어디에서도 올 수 있다.
- 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값이며, 기본 타입은 int, long, double 을 지원한다. 따라서 **char 값들을 처리할 때는 스트림을 삼가는 편이 낫다.**
- 스트림 파이프라인은 **소스 스트림**에서 시작해 **종단 연산**(terminal operation)으로 끝나며, 그 사이에 하나 이상의 **중간 연산**(intermediate operation)이 있을 수 있다. 중간 연산은 스트림을 어떠한 방식(예를 들어 필터 방식)으로 **변환**(transform)한다.
- 스트림 파이프라인은 **지연 평가**(lazy evalutation)된다. 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
- 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어인 no-op과 같다. **종단 연산을 절대 빠뜨리면 안 된다.**
- 스트림 API는 메서드 연쇄를 지원하는 **플루언트 API**(fluent API)다.
- 기본적으로 스트림 파이프라인은 순차적으로 수행된다. 병렬로 실행하려면 파이프라인을 구성하는 스트림 중 하나에서 parallel 메서드를 호출하면 되지만, 잘 쓰지 않는다(아이템 48).

## 스트림을 쓰면 좋은 경우

- 원소들의 시퀀스를 **일관되게 변환**한다.
- 원소들의 시퀀스를 **필터링**한다.
- 원소들의 시퀀스를 **하나의 연산을 사용해 결합**한다(더하기 ,연결하기, 최솟값 구하기 등).
- 원소들의 시퀀스를 **컬렉션에 모은다**(아마도 공통된 속성을 기준으로 묶어가며),
- 원소들의 시퀀스에서 **특정 조건**을 만족하는 원소를 찾는다.

> 참고로 알아두자. **람다에서는 타입 이름을 자주 생략하기 때문에 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.**
>
> 또한, **스트림을 반환하는 메서드 이름은 원소의 정체를 알려주는 복수 명사로 쓰기를 강력히 추천한다.** 예를 들어 스트림이 반환하는 원소들이 소수라면 메서드 이름을 `primes()`로 짓자.

## (스트림이 아닌) 반복문 코드 블록을 쓰면 좋은 경우

- 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다에서는 final이나 사실상 final인 변수만 읽을 수 있고, 지연변수를 수정하는 건 불가능하다.
- 코드 블록에서는 return 문을 사용해 메서드에서 빠져나가거나, break나 continue 문으로 블록 바깥의 반복문을 종료하거나 반복을 한 번 건너뛸 수 있다. 또한 메서드 선언에 명시된 검사 예외를 던질 수 있다. 하지만 람다로는 이 중 어떤 것도 할 수 없다.
- 한 데이터가 파이프라인의 여러 단계(stage)를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하는 경우 람다를 사용하기 어렵다. 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하면 원래의 값은 잃는 구조이기 때문이다.

## 스트림과 반복문 블록 사용 예시: newDeck 메서드

다음은 카드 덱을 초기화하는 작업을 구현한 코드다. 카드는 숫자(rank)와 무늬(suit)를 묶은 불변 값 클래스이고, 숫자와 무늬는 모두 열거 타입이다. 

먼저 이해하기 쉬운 반복문 코드를 살펴보자.

```java
public static List<Card> newDeck() {
    List<Card> result = new ArrayList<>();
    for (Suit suit : Suit.values()) {
        for (Rank rank : Rank.values()) {
            result.add(new Card(suit, rank));
        }
    }
    return result;
}
```

다음 코드에서는 같은 내용을 스트림으로 작업하였다. 특히 중간 연산에 쓰인 flatMap에 주목하자. **flatMap은 스트림의 원소 각각을 하나의 스트림으로 매핑한 다음, 그 스트림들을 다시 하나의 스트림으로 합치는 역할을 한다.** 이를 **평탄화**(flattening)라고도 한다. 

```java
public static List<Card> newDeck() {
    return Stream.of(Suit.values())
        .flatMap(suit ->
			Stream.of(Rank.values())
             	.map(rank -> new Card(suit, rank)))
        .collect(toList());
}
```

위의 반복문 코드와 스트림 중 어느 것을 선택해야 하는지는 정해지지 않았다. 자신이 원하는 방식 또는 개발 환경이 지원하는 방식에 맞춰 선택하면 된다. 어쩌면 두 가지를 적절히 조합하여 사용하는 게 나을 수도 있다. 결국 **스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.**


