# 10장. 예외(p385~412)

> 이번 장에서는 예외를 효과적으로 활용하는 지침을 다룬다.

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라(p390~392)

문제 상황을 알리기 위해 자바는 세 가지 throwable 타입을 제공한다

- 검사 예외
- 런타임 예외
- 에러

언제 무엇을 사용해야 할지 모를 때 아래 지침들을 참고하면 좋다.

**호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.** 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파할 것이다. 따라서 메서드 선언에 포함된 검사 예외는 해당 메서드를 호출했을 때 발생할 수 있는 결과임을 API 사용자에게 알려준다.

다르게 설명하면, API 설계자가 그 API의 사용자에게 검사 예외를 던져주어 예외 상황에서 회복해내라고 요구하는 것이다. 따라서 사용자는 예외를 잡아 별다른 조치를 취할 수 있게 처리하는 것이 좋다(아이템 77). 

비검사 throwable은 두 가지, 런타임 예외와 에러가 있다. 동작 측면에서는 두 개가 다르지 않다. 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다. 이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.

**프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.** 특히 특정 자원의 고갈 상황이 복구 가능하다고 믿으면 검사 예외를 사용하지만, 그렇지 않은 경우 런타임 예외를 사용하자. 이를 확신하기 어렵다면 비검사 예외를 선택하는 편이 낫다(아이템 71).

> 에러(Error)는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다. 자바 언어 명세가 요구하는 것은 아니지만 업계에 널리 퍼진 규약이니, Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하기 바란다.
>
> 결국, **구현하는 비검사 throwable은 모두 (직접적이든 간접적이든) RuntimeException의 하위 클래스여야 한다**.
>
> Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다(AssertionError는 예외다).

Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들고 싶을 수 있다. 하지만 이로울 게 없으니 절대 사용하지 말라! throwable은 정상적인 검사 예외보다 나은 점이 하나도 없고, 단지 API 사용자를 헷갈리게 만든다. 

또 한 가지 하지 말아야 할 것이 있다. 예외의 메서드에서 오류 메시지를 얻고 이를 파싱해서 사용해서는 안 된다. JVM이나 릴리스에 따라 포맷이 달라질 수 있기 때문이다. 

검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다. 따라서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공해야 한다. 예를 들어, 쇼핑몰에서 물건을 구입하려는 데 카드 잔고가 부족하여 검사 예외가 발생했다고 하자. 이 경우 예외는 잔고가 얼마나 부족한지를 알려주는 접근자 메서드를 제공해야 한다(아이템 75).

## 마무리

- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.
- 확실하지 않다면 비검사 예외를 던지자.
- 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지 말자.
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드를 제공하자.


