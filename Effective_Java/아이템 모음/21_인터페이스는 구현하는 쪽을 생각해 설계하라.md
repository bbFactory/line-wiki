# 4장. 클래스와 인터페이스(p95~152)

## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라(p136~138)

## 디폴트 메서드의 등장

자바 8 이전에는 인터페이스에 메서드를 추가하면 보통 컴파일 오류가 발생했다. 기존 구현체가 새로 선언된 메서드를 가지는 일이 흔치 않았기 때문이다. 

자바 8에서는 이런 상황이 개선되어 **기존 인터페이스에 디폴트 방식으로 메서드를 추가하는 것이 가능해졌다**. 하지만 새로운 메서드 선언으로 발생하는 위험 요소가 완전히 해결되지는 않았다. 

## 디폴트 메서드의 위험성

**디폴트 메서드 선언은 해당 인터페이스를 구현한 모든 클래스에서 디폴트 구현이 쓰이게 한다.** 그래서 디폴트 메서드의 선언은 종종 기존 구현체들과 충돌을 일으킬 수 있다. 

다음 예시에서 위험성을 살펴보자. 자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다. 좋은 품질을 가진, 범용적인 코드가 추가된 것이지만, 추가된 코드는 모든 곳에서 매끄럽게 동작하지 않는다. 구체적으로 Collection 인터페이스에 추가된 removeIf 메서드를 살펴보자. 

```java
default boolean removeIf(Precicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

이 디폴트 메서드의 선언은 아파치 커먼즈 라이브러리의 SynchronizedCollection 클래스 사용시 위험할 수 있다. SynchronizedCollection는 본래 모든 메서드 호출을 동기화 하는 역할을 수행한다. 하지만 removeIf 메서드를 재정의하고 있지 않기 때문에 동기화가 완벽히 이루어지지 않는다. 따라서 여러 개의 스레드에서 SynchronizedCollection 인스턴스를 공유하는 경우 ConcurrentModificationException 등의 오류가 발생할 수 있다.

다행히 자바 플랫폼 라이브러리에서 위의 문제에 대해 예방 조치를 취했다고 하지만, 자바 플랫폼에 속하지 않은 구현체들은 매번 예방 조치를 할 수 없다는 문제가 남아 있다.

결국 **디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.** 따라서 **꼭 필요한 경우가 아니면 기존 인터페이스에 디폴트 메서드를 추가하는 일을 피해야 한다**(새로운 인터페이스를 만들 때 디폴트 메서드를 선언하는 것은 오히려 유용한 방법이다). 

## 새로운 인터페이스 구현 시 고려할 점

새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거치자. 서로 다른 방식으로 최소한 세 가지는 구현해봐야 한다. 물론 각 인터페이스의 인스턴스를 활용하는 클라이언트도 여러 개 만들어봐야 한다. 

아직 바로잡을 기회가 아직 남아 있을 때 결함을 발견하고 고치자. **인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 수도 있겠지만, 절대 그 가능성에 기대서는 안 된다.**


