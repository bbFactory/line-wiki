# 10장. 예외(p385~412)

> 이번 장에서는 예외를 효과적으로 활용하는 지침을 다룬다.

## 아이템 71. 필요 없는 검사 예외 사용은 피하라(p393~395)

어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다. API 사용자에게는 두 경우 모두 부담이 있기 때문에 검사 예외를 과하게 사용하는 경우 오히려 API 사용이 불편해진다.

API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우에 검사 예외를 사용하자. 그리고 그외의 경우라면 비검사 예외를 사용하자. 

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다(아이템 55). 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다. 단, 이 경우에는 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다. 반면, 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다(아이템 70).

또 다른 방법으로, 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다. 다음은 리팩터링을 하기 전으로, 검사 예외를 던지는 메서드 예시 코드다.

```java
try {
  obj.action(args);
} catch (TheCheckedException e) {
  ... // 예외 상황에 대처한다.
}
```

리팩터링을 거치면 다음과 같아진다.

```java
if (obj.actionPermitted(args)) {
  obj.action(args);
} else {
  ... // 예외 상황에 대처한다.
}
```

검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸었다. 상태 검사 메서드와 비검사 예외를 던지는 메서드를 만든 것이다. 

프로그래머가 이 메서드가 성공하리라는 걸 안다거나, 실패 시 스레드를 중단하길 원한다면 다음처럼 한 줄로 작성해도 무방하다.

```java
obj.action(args);
```

동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 위에서의 리팩터링은 적절하지 않다. actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있기 때문이다.

## 마무리

- 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.


