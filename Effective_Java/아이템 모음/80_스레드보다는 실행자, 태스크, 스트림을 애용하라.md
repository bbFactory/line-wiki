# 11장. 동시성(p413~448)

> 이번 장에는 동시성 프로그램을 명확하고 정확하게 만들고 문서화를 잘 하는 데 도움이 되는 조언들을 담았다.

## 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라(p428~430)

java.util.concurrent 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다. 단순히 작업 큐는 덕분에 다음 한 줄로 구현이 가능하다.

```java
ExecutorService exec = Executors.newSingleThreadExecutor();
```

다음과 같이 이 실행자에 실행할 태스크(task; 작업)를 넘길 수 있다.

```java
exec.execute(runnable);
```

그리고 다음으로 실행자를 우아하게 종료시킬 수 있다(이 작업이 실패하면 VM 자체가 종료되지 않는다).

```java
exec.shutdown();
```

실행자 서비스의 기능은 이 외에도 많다. 다음은 실행자 서비스의 주요 기능들이다.

- 특정 태스크가 완료되기를 기다린다(아이템 79의 코드 79-2에 나오는 get 메서드).
- 태스크 모음 중 아무것 하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다 (awaitTermination 메서드).
- 완료된 태스크들의 결과를 차례로 받는다 (ExecutorCompletionservice 이용).
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor 이용).

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다. 스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다. java.util.concurrent.Executors의 정적 팩터리들을 이용해 필요한 실행자를 생성하자.

만약 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 된다. 이 클래스로는 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다.

작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이다. 

하지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다! CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행된다. 만약 서버가 아주 무겁다면 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성하며 상황을 더욱 악화시킨다.

따라서 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택해야 한다. 또는 완전히 통제 가능한ThreadPoolExecutor를 직접 사용하는 것이 좋다.

실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다. 작업 단위를 나타내는 핵심 추상 개념이 태스크다. 태스크에는 두 가지가 있는데, Runnable과 그 사촌인 Callable이다(Callable은 Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다). 이들 태스크를 수행하는 일반적인 메커니즘이 바로 실행자 서비스다. 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다. (컬렉션 프레임워크가 데이터 모음을 담당하듯) 실행자 프레임워크가 작업 수행을 담당해준다고 생각하면 된다.


