# 12장. 직렬화(p449~482)

> 이번 장은 객체 직렬화를 다룬다. 객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘이다.
>
> 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화할 수 있다. 이번 장은 직렬화가 품고 있는 위험과 그 위험을 최소화하는 방법에 집중한다.

## 아이템 87. 커스텀 직렬화 형태를 고려해보라(p459~466)

**먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.** 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다. 

**객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.**  

**기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.**

**객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.**

1. **공개 API가 현재의 내부 표현 방식에 영구히 묶인다.** 앞의 예에서 private 클래스인 StringList.Entry가 공개 API가 되어 버린다.
2. **너무 많은 공간을 차지할 수 있다.** 앞 예의 직렬화 형태는 연결 리스트의 모든 엔트리와 연결 정보까지 기록했지만, 엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없다. 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.
3. **시간이 너무 많이 걸릴 수 있다.** 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다. 앞의 예에서는 간단히 다음 참조를 따라 가보는 정도로 충분하다.
4. **스택 오버플로를 일으킬 수 있다.** 기본 직렬화 과정은 객체 그래프를 재귀 순회하는데, 이 작업은 중간 정도 크기의 객체 그래프에서도 자칫 스택 오버플로를 일으킬 수 있다. 내 컴퓨터에서는 StringList 에 원소를 1,000~1,800개 정도 담으면 직렬화 과정에서 StackoverflowError가 뜬다. 어떤 플랫폼에서는 이 문제가 전혀 나타나지 않을 수도 있다.

**해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.**

**어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.** 직렬 버전 UID 선언은 각 클래스에 아래 같은 한 줄만 추가해주면 끝이다.

```java
private static final long serialVersionUID = <무작위로 고른 long 값>;
```

**구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.**

## 마무리

- 클래스를 직렬화하기로 했다면 (아이템 86) 어떤 직렬화 형태를 사용할지 심사숙고하자.
- 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안하자.
- 한번 공개된 메서드는 향후 릴리스에서 제거할 수 없듯이, 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다. 


