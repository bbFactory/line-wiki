# 9장. 일반적인 프로그래밍 원칙(p343~384)

> 이번 장에서는 자바 언어의 핵심 요소라고 할 수 있는 다음 내용들을 다룬다.
>
> - 지역변수
> - 제어구조
> - 라이브러리
> - 데이터 타입 
> - 리플렉션과(언어 경계를 넘나드는 기능) 
> - 네이티브 메서드
> - 최적화와 명명 규칙

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라(p358~361)

## 자바의 2가지 데이터 타입

자바의 데이터 타입은 크게 두 가지로 나뉜다.

- **기본 타입**: int, double, boolean 등
- **참조 타입**: String, List 등

이번 아이템에서 살펴볼 **박싱된 기본 타입**은 하나의 기본 타입에 대응되는 하나의 참조 타입을 의미한다. 예를 들어 int, double, boolean 이라는 기본 타입에 대응되는 Integer, Double, Boolean 참조 타입이 각각 박싱된 기본 타입이다.

오토박싱과 오토언박싱 덕분에 기본 타입과 박싱된 기본 타입을 크게 구분하지 않고 사용할 수 있지만(아이템 6), 두 개가 같은 것은 아니다. 둘 사이에는 엄연히 차이가 존재하기 때문에 둘 중 어떤 타입을 사용할 것인지는 상당히 중요하다.

## 기본 타입과 박싱된 기본 타입의 차이

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다. 

- **차이 1**: 기본 타입은 그 값만 가지지만, 박싱된 기본 타입은 값과 함께 식별성(identity)이라는 속성을 가진다. 즉, 박싱된 기본 타입은 두 인스턴스가 값이 같아도 서로 다르다고 식별될 수 있다.
- **차이 2**: 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 유효하지 않은 값(null)을 가질 수 있다.
- **차이 3**: 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용 면에서 더 효율적이다.

## 잘못된 타입 사용의 예

앞서 살펴본 타입 간의 차이를 무시하고 코드를 작성하다가는 심각한 오류를 유발할 수 있다. 다음 예를 보자. Integer 값을 오름차순으로 정렬하는 비교자다.

```java
Comparator<Integer> naturalOrder = 
	(i,j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

위의 코드는 어떤 문제를 가지고 있을지는 다음 코드의 값을 출력해보면 바로 알 수 있다. naturalOrder.compare(new Integer(7), new Integer(7)); 두 Integer 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다. 값이 동일한데도 첫 번째 Integer가 두 번째보다 크다고 본 것이다.

이 문제는 `i==j` 지점에서 발생한다. 이 비교 검사에서 두 '객체 참조'의 식별성을 검사하는데, 서로 다른 Integer 인스턴스이기 때문에 (i와 j의 값이 같더라도) false 결과를 반환하는 것이다. 이처럼 (같은 객체를 비교하는 게 아니라면) **박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.**

실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder()를 사용하거나, 다음의 수정된 코드를 사용하자. 수정된 코드에서는 모든 비교를 기본 타입 변수로 수행하고 있다.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
  int i = iBoxed, j = jBoxed; // 오토박싱
  return i < j ? -1 : (i == j ? 0 : 1);
}
```

잘못된 타입 사용의 예는 더 있다. 다음 예를 살펴보자.

```java
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++){
    	sum += 1;
    }
	System.out.println(sum);
}
```

이 프로그램은 지역변수 sum을 박싱된 기본 타입으로 선언하여 성능이 끔찍이 나빠졌다. 

## 박싱된 기본 타입은 언제 써야 할까?

박싱된 기본 타입을 사용하기에 적절한 경우가 몇 가지 있다.

- **경우 1**: **컬렉션의 원소, 키, 값으로 쓴다.** 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.
- **경우 2**: **매개변수화 타입이나 매개변수화 메서드(5장)의 타입 매개변수로 쓴다.** 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다. 예를 들어 변수를 `ThreadLocal<int>` 타입으로 선언하는 대신 `ThreadLocal<Integer>`를 써야 한다. 
- **경우 3**: **리플렉션(아이템 65)을 통해 메서드를 호출할 때 쓴다.**

## 마무리

- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다.
- 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 동일 비교를 원하는 대로 하지 못할 수 있다. 
- 또한 == 비교시, 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, **언박싱 과정에서 NullPointerException을 던질 수 있다.** 
- 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.


