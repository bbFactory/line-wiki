# 2장. 객체 생성과 파괴(p7~94)

## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라(p8~13)

**객체 생성** 을 하기 위해 다음의 두 가지 방법을 사용할 수 있다.

1. **public 생성자**
2. **정적 팩터리 메서드**(static factory method)

> 정적 팩터리 메서드는 **클래스의 인스턴스**를 반환하는 정적 메서드이다. 아래 예시를 살펴보자. <br/> 아래 valueOf 메서드는 원시 타입 boolean 값을 매개변수로 받고, 이를 Boolean 객체 참조로 변환한 후에 반환한다.
>
> ```java
> public static Boolean valueOf(boolean b) {
> return b ? Boolean.TRUE : Boolean.FALSE;
> }
> ```

궁금한 점은 생성자와 정적 팩터리 메서드 둘 중 어느 방법으로 객체를 생성하는 게 더 좋은가 이다. 본서에서는 public 생성자보다 **정적 팩터리 메서드 사용을 추천한다.** 그 이유는 다음의 다섯 가지의 장점과 소수의 단점을 통해 살펴보자.

## 정적 팩터리 메서드 사용의 장점

### 1. 이름을 가질 수 있다.

정적 팩터리는 생성자와 달리 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다. 예를 들어 '값이 소수인 BigInteger 객체를 생성한다'고 해보자. 생성자인 BigInteger(int, int, Random)와 정적 팩터리 메서드인 BigInteger.probablePrime 둘 중 어느 이름이 앞의 문장의 의미를 더 잘 전달하는가? (후자일 것이다.)

입력 매개변수들의 순서를 다르게 하여 생성자를 새로 추가하는 방식은 추천하지 않는다. 그런 API는 작성할 때나 사용할 때 엉뚱한 실수를 유발한다. 코드를 읽는 사람 입장에서도 클래스의 설명 문서를 따로 찾아보지 않고는 의미를 쉽게 파악하기 힘들다.

반면, **특정 이름**을 가지는 정적 팩터리 메서드는 훨씬 유연하다. 한 클래스에 같은 시그니처의 생성자가 여러 개 필요하다면, 생성자를 정적 팩터리 메서드로 바꾸고 각각에 어울리는 이름을 지어주도록 하자.

### 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

앞에서 살펴본 Boolean.valueOf(boolean) 메서드는 호출 때마다 인스턴스를 생성하지 않는다. 아니, 객체를 아예 생성하지 않는다. 이처럼 정적 팩터리 방식은 **객체 생성시 비용**을 줄여준다. 특히 똑같은 객체를 자주 써야 하는데 객체의 생성 비용이 큰 경우라면 정적 팩터리 메서드를 사용함으로써 성능을 상당히 높일 수 있다.

### 3. 반환 타입의 하위 타입 객체를 반환할 수 있다.

정적 팩터리 메서드는 반환할 객체의 클래스를 유연하게 선택한다. 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 **인터페이스 기반 프레임워크** 에서 이는 커다란 장점이자 핵심 기술이다. 프로그래머는 명시된 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 굳이 별도 문서를 찾아가며 실제 구현 클래스가 무엇인지 알아보지 않아도 된다(**자바 컬렉션 프레임워크**에 대해 공부해보자).

### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

**반환하는 타입의 하위 타입**이기만 하면 어떤 클래스의 객체이든 반환할 수 있다. 예를 들어 EnumSet 클래스는 생성자를 사용할 수 없고, 오직 정적 팩터리 메서드만으로 객체를 생성할 수 있다. 정적 팩터리 메서드를 사용할 때 EnumSet은 자기 자신을 반환할 수도 있고, 다음 두 가지 하위 클래스의 인스턴스를 반환할 수도 있다. (OpenJDK 기반에서) 원소의 개수가 64개 이하이면 RegularEnumSet의 인스턴스를, 65개 이상이면 JumboEnumSet의 인스턴스를 반환한다. 

> 중요한 건 클라이언트는 이 두 클래스의 존재를 모른다는 것이다. 만약 원소가 적을 때 RegularEnumSet을 사용할 이점이 없어진다면 다음 릴리스 때는 이를 삭제해도 아무 문제가 없다. 비슷하게, 성능을 더 개선한 세 번째, 네 번째 클래스를 다음 릴리스에 추가할 수도 있다. 클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수도 있고 알 필요도 없다. EnumSet의 하위 클래스이기만 하면 되는 것이다.

### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

이 부분은 본서와 **서비스 제공자 프레임워크**(service provider framework)를 참고하기로 하자.

## 정적 팩터리 메서드 사용의 단점

이번에는 정적 팩터리 메서드를 사용할 때 단점에 대해 알아보자.

### 1. 정적 팩터리 메서드만 제공할 경우 하위 클래스를 만들 수 없다.

정적 팩터리 메서드만 사용한다는 건 **private 생성자**만 사용한다는 말이다. public / protected 생성자가 없으니 외부에서는 더 이상 생성자를 통해 인스턴스를 생성할 수 없다. 객체 생성 외에도 public  / protected 생성자를 통해 할 수 있는 일들을 제공받지 못한다(예를 들어 상속). 이런 점에서 프로그래머는 불편함을 느낄 수 있다.

하지만 그럼에도 이 제약은 오히려 장점으로 여길 만한 요소들이 있다. 상속 대신 **컴포지션** 사용(아이템 18)을 유도한다는 점과 **불변 타입**(아이템 17)을 만들 수 있다는 점은 정적 팩터리 메서드 사용을 단점 대신 장점으로 승화시킨다.

### 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

사용자는 클래스가 가지는 정적 팩터리 메서드의 사용법을 하나하나 찾아야 한다. 특정 이름을 지을 수 있다는 장점이 여기에서는 단점이 된다. 사람마다 메서드 이름을 자유분방하게 짓는 대신 **널리 알려진 규약**을 따라 이름을 짓는다면 이 문제를 어느 정도 완화할 수 있다. 

> 다음은 정적 팩터리 메서드에 흔히 사용하는 명명 방식들이다.

### from( )

> **하나의 매개변수** 를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드

  예) `Date d = Date.from(instant);`

### of( )

**여러 매개변수** 를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드

  예) `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);` 

### valueOf( )

from과 of의 더 **자세한** 버전<br />  예) `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);` 

### instance( ) 또는 getInstance( )

(매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.<br />  예) `StackWalker luke = StackWalker.getInstance(options);`

### create( ) 또는 newInstance( )

instance 또는 getInstance와 같지만, **매번 새로운 인스턴스**를 생성해 반환함을 보장한다.<br />  예) `Object newArray = Array.newInstance(classObject, arrayLen);` <br />

### getType( )

**getInstance**와 같으나 생성할 클래스가 아닌 **다른 클래스**에 팩터리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입이다.<br />  예) `FileStore fs = Files.getFileStore(path);` 

### newType( )

**newInstance**와 같으나, 생성할 클래스가 아닌 **다른 클래스**에 팩터리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입이다.<br />  예) `BufferedReader br = Files.newBufferedReader(path);` 

### type( ) 

getType과 newType의 **간결한** 버전이다.<br />  예) `List<Complaint> litany = Collections.list(legacyLitany);`
