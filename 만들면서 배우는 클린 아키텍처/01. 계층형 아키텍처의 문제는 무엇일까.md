# 01. 계층형 아키텍처의 문제는 무엇일까

* 일반적으로 사용되는 웹 애플리케이션의 3계층 아키텍처는 다음과 같습니다.

  <img width="270" alt="image" src="https://user-images.githubusercontent.com/49539592/147830229-dc006c9d-2dbe-4b6c-8fcd-e390c496c00c.png">

  > 웹, 도메인, 영속성 계층으로 구성된 전통적인 웹 애플리케이션 구조

* **웹** 계층에서는 요청을 받아 **도메인** 혹은 **비즈니스** 계층에 있는 서비스로 요청을 보냅니다.
* 서비스에서는 비즈니스 로직을 수행하면서, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출합니다.
* 현재 바라보는 아키텍처는 계층(layer)별로 잘 구분되어 있기 때문에 느낌적으로는(?) 그다지 문제가 없어 보입니다.
* 하지만 과연 그럴까요? 다음부터 소개할 섹션들에서 계층형 아키텍처가 가진 문제들을 하나하나 살펴보겠습니다.

## 1.1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

### 1.1.1. 계층형 아키텍처의 뿌리: 데이터베이스

* 전통적인 계층형 아키텍처를 다시 보겠습니다.
* 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존합니다. 결국 전통적인 계층형 아키텍처의 최종 뿌리는 영속성 계층(데이터베이스)입니다.
* 모든 것이 영속성 계층을 토대로 만들어지는 것은 어떤 의미를 가질까요? 만약 문제가 있다면 어떤 문제를 가질까요? 다음 섹션에서 알아보겠습니다.

### 1.1.2. 애플리케이션의 목적: 상태 보다는 행동

* 애플리케이션의 목적은 무엇일까요?
* 사용자가 편리하게 비즈니스(서비스)를 수행할 수 있도록 돕는 것입니다.
* 이를 위해선 비즈니스 운영 규칙(또는 정책)을 모델로 만들어야 하는데, 우리는 상태가 아니라 행동(behavior)을 중심으로 모델링 작업을 합니다.
* 상태가 중요한 요소임은 맞지만 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어갑니다.
  > 회원가입, 상품등록, 주문 등을 생각해보면 사실 상태는 행동에서부터 시작되고, 결정됩니다.
* 반면, 데이터베이스는 행동이 아닌 상태(state)를 저장하고 있다는 사실에 주목해야 합니다.
* 우리는 의존성의 방향에 따라 `데이터베이스 주도 설계` 를 한 것이지만, 비즈니스 관점에서는 사실 맞지 않는 방법을 선택하고 있었던 것입니다.
* 비즈니스 관점에서라면 도메인 로직을 먼저 확인해야 하고, 그 이후에 영속성 계층과 웹 계층을 만들어야 합니다.

### 1.1.3. 영속성 계층과 도메인 계층의 강한 결합

* 특히 영속성 계층과 도메인 계층이 강하게 결합하는 경우 주의가 필요합니다.
* 자칫 서비스에서 **영속성 모델을 비즈니스 모델처럼 사용하게 되는** 문제가 발생하기 때문입니다.
* 이는 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업을 별도로 하게 합니다.
* 영속성 코드가 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워지고 테스트를 비롯하여 결국 유연한 설계가 어려워집니다.

## 1.2. 지름길을 택하기 쉬워진다

* 전통적인 계층형 아키텍처에서는 일반적으로 다음 규칙이 적용됩니다.
  > 어느 한 계층의 컴포넌트는 같은 계층에 있는 컴포넌트나 그 하위 계층의 컴포넌트에만 접근할 수 있다.
* 만약 상위 계층에 위치한 컴포넌트에 접근하고 싶다면 자신의 계층 아래로 해당 컴포넌트를 내리기만 하면 됩니다.
* 계층형 아키텍처에서는 이러한 유혹이 강하게 일어납니다. 하지만 이러한 방식을 수년간 거친다면 어떻게 구조가 변할까요?

  <img width="602" alt="image" src="https://user-images.githubusercontent.com/49539592/147832003-234e3f0d-09aa-42d9-b65a-46bdaf148a86.png">

* 영속성 계층은 모든 것에 접근할 수 있기 때문에 시간이 지날수록 점차 비대해질 것입니다.
* 그리고 이는 계층을 나누어 역할을 분리하고자 했던 애초의 목적을 잃게 만듭니다.
* 또한 계층 하나만 사용하는 것과 다를 게 없어지므로 계층을 나누었을 때 얻을 수 있는 이점들을 포기하게 만듭니다.

## 1.3. 테스트하기 어려워진다

* 계층형 아키텍처를 사용할 때 계층을 건너뛰는 일들은 종종 발생합니다.
* 예를 들어 엔티티의 필드 하나만 변경하는 경우, 웹 계층에서 도메인 계층을 거치지 않고 영속성 계층에 바로 접근을 시도할 수 있습니다 (아래 그림 참고).

  <img width="606" alt="image" src="https://user-images.githubusercontent.com/49539592/147832385-c4ed5056-ca10-4e90-9b13-0eab1844bfad.png">

* 하지만 **도메인 계층을 건너뛰는 것은 도메인 로직 코드를 여기저기 흩어지게 만듭니다.**
* 위에서 예시 든 대로 엔티티의 필드 하나를 변경하기 위해 도메인 로직을 웹 계층에서 구현하게 되면 어떤 문제가 발생할까요?
* 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹(mocking)해야 합니다. 이런 경우 필연적으로 **단위 테스트의 복잡도가 올라가며**, 최악의 경우 복잡도가
  너무 높아진 테스트를 건너뛰게 됩니다.

## 1.4. 유스케이스를 숨긴다

### 1.4.1. 혼잡한 아키텍처의 문제 1

* 도메인 계층을 생략하고 웹과 영속성 계층을 바로 연결하거나, 특정 컴포넌트를 무분별하게 영속성 계층으로 내리면 아키텍처 구조가 혼잡해집니다.
* 아키텍처는 **기능을 새로 추가하거나 변경할 때 코드를 놓을 적절한 위치를 찾는 데 도움이 되어야 하지만** 이렇게 지름길만 추구한 혼잡한 아키텍처는 전혀 도움이 되지
  못합니다.
* 불분명한 계층은 새로은 기능의 코드를 어디에 두어야 할지 정할 때 혼란을 가져다 줍니다.
* 특히나 이미 기존의 코드가 뒤죽박죽인 상황에서 간단한 작업을 해야 하는 경우면, 개발자는 크게 양심의 가책을 느끼지 않고 몇몇 단계를 건너뛰기 쉬울 것입니다.

### 1.4.2. 혼잡한 아키텍처의 문제 2

* 다른 문제도 있습니다.
* 계층형 아키텍처의 또다른 한계 중 하나는 **도메인 서비스의 '너비' 에 관해 규칙을 강제하지 않는다** 는 것입니다.
* 그렇기 때문에 시간이 지나면 아래 그림과 같이 여러 개의 유스케이스를 담당하는 비대한 서비스가 만들어지기도 합니다.

  <img width="622" alt="image" src="https://user-images.githubusercontent.com/49539592/147870727-4265a79d-3d5d-4468-83e2-a70c37e21338.png">
* 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 만들고, 반대편에서 웹 계층의 많은 컴포넌트가 이 서비스에 의존하게 만듭니다.
* 이렇게 되면 **서비스를 테스트하기 어려워지고, 코드 상에서 특정 유스케이스를 찾기도 어려워집니다.**
* 이를 대신하여, 만약 고도로 특화된 (좁은) 도메인 서비스가 유스케이스 하나씩 담당하게 만들면 어떨까요?
* UserService에 사용자 등록 유스케이스를 넣는 것이 아니라, RegisterUserService라는 특화된 서비스 안에 넣으면 넓은 서비스의 문제를 피할 수 있을
  것입니다.

## 1.5 동시 작업이 어려워진다

* 계층형 아키텍처는 동시 작업 측면에서는 그다지 도움이 되지 않습니다.
* 애플리케이션에 새로운 유스케이스를 추가한다고 가정하겠습니다. 3명의 개발자가 있다고 할 때, 각각 웹 계층, 도메인 계층, 영속성 계층을 작업하는 방식으로 일을 진행할 수
  있을까요?
* 답은 그럴 수 없다 입니다.
* 계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 합니다. 그런 다음 도메인 계층을, 그리고 나서 마지막으로 웹 계층을 개발해야
  합니다.
* 누군가는 인터페이스를 잘 정의하면 되지 않느냐고 되물을 수 있습니다. 하지만 이는 언제까지나 데이터베이스 주도 설계를 하지 않는 경우에만 가능한 얘기입니다.
* 특히 코드에 넓은 서비스를 가지고 있다면 서로 다른 기능을 동시에 작업하는 일은 더욱 더 어렵습니다.

