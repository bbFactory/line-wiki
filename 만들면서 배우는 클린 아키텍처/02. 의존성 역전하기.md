# 02. 의존성 역전하기

* 1장에서 계층형 아키텍처의 단점에 대해 알아보았습니다.
* 단점만 나열하고 끝낼 수는 없으니, 이번 장에서는 **계층형 아키텍처의 대안** 에 대해 살펴보겠습니다.
* 먼저는 단일 책임 원칙(Single Responsibility Principle, SRP)과 의존성 역전 원칙(Dependency Inversion Principle, DIP)
  을 살펴보는 것으로 내용을 시작하겠습니다.

## 2.1. 단일 책임 원칙

* **단일 책임 원칙** 의 일반적인 해석은 다음과 같습니다.

  > 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

* 이 내용도 좋은 이야기이고 맞는 이야기지만, 단일 책임 원칙의 실제 의도는 아닙니다.
* 단일 책임 원칙의 **실제 정의** 를 표현하면 다음과 같습니다.

  > **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.**

* 위의 정의에 따르면 단일 `책임`은 곧, 단일 **`변경 이유`** 를 의미합니다.
* 컴포넌트를 변경할 이유는 딱 하나뿐이어야 한다는 것인데, 그외의 다른 이유 때문에 특정 컴포넌트를 변경해야 한다면 단일 책임 원칙을 잘 지킨 것이 아닙니다.
* 중복되는 얘기지만, 단일 책임 원칙을 잘 지켰다면 컴포넌트를 변경할 이유는 단 한 가지뿐이어야 합니다.
* 그 하나뿐인 이유를 건드리지 않는 한 소프트웨어가 어떻게 변하든지 간에 우리는 그 컴포넌트를 신경 쓸 필요가 전혀 없고, 컴포넌트는 여전히 의도한 동작을 수행해야 합니다.
* 하지만 **의존성** 이란 변수는 단일 책임 원칙을 쉽게 깨뜨립니다.
* 특정 컴포넌트에 한 번 **의존성**이 더해지면, 변경 이유를 단 하나만 유지하는 것이 어려워집니다.

  <img width="596" alt="image" src="https://user-images.githubusercontent.com/49539592/147872510-50fb614b-0429-416a-95f9-0a67ac0955d2.png">

* 사실 컴포넌트에 **의존성이 하나씩 더해질 때마다 컴포넌트의 변경 이유도 하나씩 더해집니다.** 그게 점선 화살표로 표시한 전이 의존성(transitive dependency)
  일지라도 말입니다.
* 위의 그림에서 컴포넌트 A는 거의 모든 컴포넌트에 의존하는 반면 컴포넌트 E는 어떤 것에도 의존하지 않습니다.
* 따라서 컴포넌트 E의 변경 이유는 순전히 단 하나뿐인데, 새로운 요구사항 때문에 E의 기능을 바꿔야 할 때뿐입니다.
* 반면에 컴포넌트 A는 자신이 의존하고 있는 컴포넌트 중 하나가 바뀌면 자신도 함께 바뀌어야 합니다(다형성을 지킬 경우 반드시 바뀌어야 하는 것은 아닙니다).
* A와 같이 의존하는 요소가 많고 변경 이유가 많은 컴포넌트일수록 변경 비용이 높기 때문에 가능한 단일 책임 원칙을 지키는 것이 좋습니다.

## 2.2. 의존성 역전 원칙

* 계층형 아키텍처에서는 도메인 계층이 영속성 계층에 의존합니다. 따라서 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층을 변경해야 합니다.
* 하지만 도메인 코드는 애플리케이션에서 가장 중요한 코드이기 때문에 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸고 싶지는 않습니다.
* 이런 경우 어떻게 의존성을 제거할 수 있을까요?
* 해답은 **의존성 역전 원칙(Dependency Inversion Principle, DIP)** 에 있습니다.
* 먼저 **의존성 역전 원칙** 의 정의를 살펴보겠습니다.

  > 코드상의 **어떤 의존성이든 그 방향을 바꿀 수 있다 (역전시킬 수 있다).**

* 방향을 바꾸어 의존성을 역전시키는 것은 **의존성의 양쪽 코드를 모두 제어할 수 있을 때만** 가능합니다.
* 만약 특정 컴포넌트가 서드파티 라이브러리에 의존성이 있다고 생각해보세요. 라이브러리를 제어할 수 없기 때문에 의존성을 역전시킬 수 없을 것입니다.
* 다음에서는 도메인과 영속성 계층 간 의존성을 역전시키는 방법에 대해 알아보겠습니다.

### 2.2.1. 도메인과 영속성 계층 간 의존성 역전

* 먼저 전통적인 도메인 계층의 의존성 관계를 아래와 같이 표현하겠습니다.

  <img width="570" alt="image" src="https://user-images.githubusercontent.com/49539592/147878770-27b0f644-da10-4224-9ccc-67bce48ed121.png">

* 도메인 계층에 속한 서비스는 영속성 계층의 엔티티, 리포지토리와 상호작용하고 있습니다.
* 도메인 컴포넌트는 애플리케이션의 핵심 요소이기 때문에 가능한 '변경 이유'의 개수를 줄여야 합니다. 그리고 우리는 그 방법으로 **의존성 역전 원칙** 을 사용하려 합니다.
* 먼저 도메인 코드는 도메인 로직에 따라 엔티티들의 상태를 변경하는 일을 맡기 때문에 엔티티에 의존적입니다.
* 이 엔티티를 도메인 계층으로 올리면 어떤 일이 벌어질까요? 아래 그림을 보겠습니다.

  <img width="591" alt="image" src="https://user-images.githubusercontent.com/49539592/147879784-b9ccdb8a-e4ab-408f-a574-abc4e7403617.png">

* 이제는 영속성 계층의 리포지토리가 도메인 계층의 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성(circular dependency)이 생깁니다.
* 이를 해결하는 방법은 어느 한 쪽의 의존성을 끊는 것인데, 여기서 DIP를 적용할 수 있습니다. (이제부터 중요한 부분입니다.)
* 만약 도메인 계층에 리포지토리 인터페이스를 만들고 실제 영속성 계층의 리포지토리가 이를 구현하게 하면 어떨까요? 결과는 다음 그림과 같습니다.

  <img width="590" alt="image" src="https://user-images.githubusercontent.com/49539592/147879754-cc40e548-2baa-4975-b92c-47ffa4216021.png">

* 도메인 계층에 인터페이스를 도입함으로써 의존성을 단번에 역전시켰고, **영속성 계층이 도메인 계층에 의존하도록** 만들었습니다(이제 더 이상 도메인 계층이 영속성 계층을
  의존하지 않습니다).

  > 이 방식은 앞으로 살펴 볼 클린 아키텍처 및 헥사고날 아키텍처의 핵심적인 내용이므로 기억하고 있어야 합니다.
