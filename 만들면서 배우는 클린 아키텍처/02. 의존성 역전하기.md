# 02. 의존성 역전하기

* 1장에서 계층형 아키텍처의 단점에 대해 알아보았습니다.
* 단점만 나열하고 끝낼 수는 없으니, 이번 장에서는 **계층형 아키텍처의 대안** 에 대해 살펴보겠습니다.
* 먼저는 단일 책임 원칙(Single Responsibility Principle, SRP)과 의존성 역전 원칙(Dependency Inversion Principle, DIP)
  을 살펴보는 것으로 내용을 시작하겠습니다.

## 2.1. 단일 책임 원칙

* **단일 책임 원칙** 의 일반적인 해석은 다음과 같습니다.

  > 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

* 이 내용도 좋은 이야기이고 맞는 이야기지만, 단일 책임 원칙의 실제 의도는 아닙니다.
* 단일 책임 원칙의 **실제 정의** 를 표현하면 다음과 같습니다.

  > **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.**

* 위의 정의에 따르면 단일 `책임`은 곧, 단일 **`변경 이유`** 를 의미합니다.
* 컴포넌트를 변경할 이유는 딱 하나뿐이어야 한다는 것인데, 그외의 다른 이유 때문에 특정 컴포넌트를 변경해야 한다면 단일 책임 원칙을 잘 지킨 것이 아닙니다.
* 중복되는 얘기지만, 단일 책임 원칙을 잘 지켰다면 컴포넌트를 변경할 이유는 단 한 가지뿐이어야 합니다.
* 그 하나뿐인 이유를 건드리지 않는 한 소프트웨어가 어떻게 변하든지 간에 우리는 그 컴포넌트를 신경 쓸 필요가 전혀 없고, 컴포넌트는 여전히 의도한 동작을 수행해야 합니다.
* 하지만 **의존성** 이란 변수는 단일 책임 원칙을 쉽게 깨뜨립니다.
* 특정 컴포넌트에 한 번 **의존성**이 더해지면, 변경 이유를 단 하나만 유지하는 것이 어려워집니다.

  <img width="596" alt="image" src="https://user-images.githubusercontent.com/49539592/147872510-50fb614b-0429-416a-95f9-0a67ac0955d2.png">

* 사실 컴포넌트에 **의존성이 하나씩 더해질 때마다 컴포넌트의 변경 이유도 하나씩 더해집니다.** 그게 점선 화살표로 표시한 전이 의존성(transitive dependency)
  일지라도 말입니다.
* 위의 그림에서 컴포넌트 A는 거의 모든 컴포넌트에 의존하는 반면 컴포넌트 E는 어떤 것에도 의존하지 않습니다.
* 따라서 컴포넌트 E의 변경 이유는 순전히 단 하나뿐인데, 새로운 요구사항 때문에 E의 기능을 바꿔야 할 때뿐입니다.
* 반면에 컴포넌트 A는 자신이 의존하고 있는 컴포넌트 중 하나가 바뀌면 자신도 함께 바뀌어야 합니다(다형성을 지킬 경우 반드시 바뀌어야 하는 것은 아닙니다).
* A와 같이 의존하는 요소가 많고 변경 이유가 많은 컴포넌트일수록 변경 비용이 높기 때문에 가능한 단일 책임 원칙을 지키는 것이 좋습니다.
