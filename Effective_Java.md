# Effective Java

- **책 정보**
  - 저자 : 조슈아 블로크
  - 옮긴이 : 개앞맵시(이복연)
  - 출판사 : 프로그래밍인사이트
  - 출간일 : 2018년 11월 01일
  - 에디션 : 3rd Edition
  - 관련링크
    - 소스 코드 : https://github.com/WegraLee/effective-java-3e-source-code

- **들어가기 전에** 
  - 1회독의 경우, 책에서 기억할 만한 내용을 옮겨 적는 정도로만 만족하자. 
  - 내용을 너무 깊이 있게 파고들지 말자. (그렇지만 정리가 필요한 부분은 가능한 꼼꼼히 작성하자)



## 1장. 들어가기

- **JLS** : **자바 8용 언어 명세**(The Java Language Specification, Java SE 8 Edition)를 말한다. 제임스 고슬링(James Gosling, 자바의 아버지), 빌 조이(Bill Joy, vi 편집기 개발자) 등에 의해 작성되었다. ( [링크](https://docs.oracle.com/javase/specs/jls/se8/html/index.html) )

- **자바 타입(type) 4가지**
  - **인터페이스** ( `interface` ) - 애너테이션(annotation)은 인터페이스의 일종
  - **클래스** ( `class` ) - 열거 타입(enum)은 클래스의 일종
  - **배열** ( `array` )
  - **기본 타입** ( `primitive` )
  - 네 가지 타입 중 처음 세 가지는 참조 타입(reference type)이다. 즉, 클래스의 인스턴스와 배열은 객체(object)이나, 기본 타입 값은 그렇지 않다.
  - 클래스의 **멤버**로는 **필드**(field), **메서드**(method), **멤버 클래스**, **멤버 인터페이스**가 있다. 

- **메서드 시그니처** : 메서드 이름과 입력 매개변수(parameter)의 타입으로 이뤄진다(반환값의 타입은 시그니처에 포함되지 않는다).

- **공개 API**(exported API)
  - 줄여서 API(Application Programming Interface)는 **프로그래머가 클래스, 인터페이스, 패키지를 통해 접근할 수 있는 모든 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태(serialized form)** 를 말한다. (언어 구성 요소 중 하나인 인터페이스와 헷갈리지 않게 하기 위해 흔히 쓰는 인터페이스 대신 API를 쓴다.) 
  - API를 사용하는 프로그램 작성자(사람)를 그 API의 **사용자**(user)라 하고, API를 사용하는 클래스(코드)는 그 API의 **클라이언트**(client)라 한다.
  - 클래스, 인터페이스, 생성자, 멤버, 직렬화된 형태를 총칭해 **API 요소**(API element)라 한다. 공개 API는 그 API를 정의한 패키지의 밖에서 접근할 수 있는 API 요소로 이뤄진다. 다시 말해 모든 클라이언트가 접근할 수 있고, API 작성자가 지원하기로 약속한 API 요소들이다. 자바독(Javadoc) 유틸리티를 기본 모드로 실행하면 이 API 요소들만 담긴 문서가 만들어진다.
  - 자바 9에서는 모듈 시스템이라는 개념이 더해졌다. 자바 라이브러리에 이 모듈 개념을 적용하면 공개 API는 `해당 라이브러리의 모듈 선언(module declaration)에서 공개하겠다고 한` 패키지들의 공개 API만으로 이뤄진다. 즉, 공개할 패키지를 선택할 수 있다.



## 2장. 객체 생성과 파괴

#### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

| 장점                                                         |
| :----------------------------------------------------------- |
| 1. 이름을 가질 수 있다. <br />- 반환될 객체의 특정을 설명할 수 있다.<br />- 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자. |
| 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.<br />- 불변 클래스 또는 캐싱/재활용으로 불필요한 객체 생성을 피할 수 있다.<br />- 플라이웨이트 패턴(Flyweight pattern)과 비슷한 기법<br />- 반복되는 요청에 같은 객체를 반환하여 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다(인스턴스 통제 클래스). |
| 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.<br />- 반환할 객체의 클래스를 자유롭게 선택할 수 있다(높은 유연성).<br />- API를 만들 때 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다(인터페이스 기반 프레임워크).<br />- 프로그래머는 명시한 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 굳이 별도 문서를 찾아가며 실제 구현 클래스가 무엇인지 알아보지 않아도 된다.<br />- 나아가 정적 팩터리 메서드를 사용하는 클라이언트는 객체를 인터페이스만으로 다루게 된다(일반적으로 좋은 습관이라고 할 수 있다). |
| 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.<br />- 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. |
| 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.<br />- 이는 서비스 제공자 프레임워크를 만드는 근간이 된다(대표적으로 JDBC가 있다). |

