# Chapter 04. 스프링 시큐리티

소프트웨어 개발자로써 우리느 애플리케이션에 있는 정보를 보호하는 조치를 해야 한다. 앞으로 **스프링 시큐리티를 자동 구성** 하는 방법, **커스텀 사용자 스토리지** 를 정의하는 방법 등을 배우고, **커스텀 로그인 페이지** 를 만들어볼 것이다. 또한 **CSRF 공격** 을 막아보고, **사용자를 파악** 해보는 방법을 살펴볼 것이다.

## 4.1 스프링 시큐리티 활성화하기(p117~120)

스프링 애플리케이션의 보안에서 가장 먼저 할 일은 **스프링 부트 보안 스타터 의존성** 을 빌드 명세에 추가하는 것이다. 아래 pom.xml 파일에서 추가하는 첫 번째 `<dependency>` 항목은 스프링 부트 보안 스타터 의존성이고, 두 번째는 보안 테스트 의존성이다.

```xml
...
<dependencies>
	...
    <dependency>
    	<groupdId>org.springframework.boot</groupdId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <dependency>
    	<gorupId>org.springframework.security</gorupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

놀랍게도 방금 추가한 의존성이 스프링 애플리케이션을 안전하게 하기 위해 필요한 전부이다. 애플리케이션이 시작되면 스프링이 우리 프로젝트의 classpath에 있는 스프링 시큐리티 라이브러리를 찾아 기본적인 보안 구성을 설정한다.

어떻게 설정해 주는지 확인하려면 애플리케이션을 시작한 후, 웹 브라우저에서 홈페이지(http://localhost:8080)이나 타코 디자인 페이지(http://localhost:8080/design)에 접속해 보자. 그러면 스프링 시큐리티에서 제공하는 HTTP 기본 인증 대화상자가 나타난다.

기본 인증 대화상자에서 Username 필드에 "user"라고 입력한다. Password는 무작위로 자동 생성되어 애플리케이션 로그 파일에 수록된다. STS를 사용하는 경우 콘솔 창에 다음과 같은 로그 항목이 나타난다.

```
Using generated security password: 6838886b-edb5-40d8-bc45-395ba25a79e4
```

뒤쪽 36자리의 비밀번호를 마우스로 선택하여 복사한 후 Password 필드에 붙여넣기 하고 Sign in 버튼을 클릭하면 로그인된다. 그러면 애플리케이션을 사용할 수 있는 권한이 부여되어 우리가 접속한 페이지가 나타난다. 스프링의 username(사용자 이름)은 사용자 id를 의미한다.

지금부터는 스프링 시큐리티의 보안 자동 구성이 어떻게 제공되는지 알아보자.

먼저 보안 스타터를 프로젝트 빌드 파일에 추가만 할 경우 다음의 보안 구성이 제공된다.

- 모든 HTTP 요청 경로는 인증(authentication) 되어야 한다.
- 어떤 특정 역할이나 권한이 없다.
- 로그인 페이지가 따로 없다.
- 스프링 시큐리티의 HTTP 기본 인증(앞서 했던 인증)을 사용해서 인증된다.
- 사용자는 user 이름으로 하나만 존재한다. 비밀번호는 암호화해준다.

타코 클라우드 애플리케이션을 비롯하여 자신만의 애플리케이션을 만들 땐 보안을 제대로 구축하기 위해 더 많은 작업이 필요하며, 최소한 다음 기능을 할 수 있도록 스프링 시큐리티를 구성해야 한다.

-  스프링 시큐리티의 HTTP 인증 대화상자 대신 우리의 로그인 페이지로 인증한다.
- 다수의 사용자를 제공하며, 새로운 타코 클라우드 고객이 사용자로 등록할 수 있는 페이지가 있어야 한다.
- 서로 다른 HTTP 요청 경로마다 서로 다른 보안 규칙을 적용한다. 예를 들어 홈페이지와 사용자 등록 페이지는 인증이 필요하지 않다.

위와 같은 보안 요구를 충족하기 위해서 스프링 자동-구성이 하는 것을 대체하는 작업을 해야 한다. 우선 한 명 이상의 사용자를 가질 수 있도록 타코 클라우드에 적합한 사용자 스토어(store)를 구성해보자.

## 4.2 스프링 시큐리티 구성하기(p120~123)

우선 자바 기반으로 기본 구성 클래스를 작성해보자.

```java
package tacos.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation
    	.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation
    	.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web
    	.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web
    	.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protectesd void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/design", "/orders")
            .access("hasRole('ROLE_USER')")
            .antMatchers("/", "/**").access("permitAll")
            .and()
            .httpBasic();
    }
    
    @Override
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user1")
            .password("{noop}password1")
            .authorities("ROLE_USER")
            .and()
            .withUser("user2")
            .password("{noop}password2")
            .authorities("ROLE_USER");
    }
}
```

SecurityConfig 클래스는 간단히 말해 사용자의 HTTP 요청 경로에 대해 접근 제한과 같은 보안 관련 처리를 우리가 원하는대로 할 수 있게 해준다. 자세한 내용은 진도를 나간 이후에 알게 될 것이다.  

일단, 타코 클라우드 애플리케이션을 실행하고 웹 브라우저에서 http://localhost:8080으로 접속하자.  SecurityConfig 클래스의 configure() 메서드에서 모든 사용자의 홈페이지 접근을 허용했기 때문에 홈페이지가 바로 나타날 것이다. 그다음에 http://localhost:8080/design에 접속해 보자. 이번에는 스프링 시큐리티의 HTTP 기본 인증 대화상자 대신 다른 HTTP 로그인 대화상자가 나타날 것이다. 

사용자 이름에는 "user1", 비밀번호 필드에는 "password1"을 입력하고 로그인을 클릭하면 타코 디자인 폼이 나타날 것이다. 우리는 여기서 더 나아가 실제로 애플리케이션에서 사용할 만한 로그인 페이지를 새로 생성할 것이다. (앞의 코드에서는 비밀번호를 암호화하지 않았지만 실제로는 반드시 해야 한다.)

타코 클라우드 애플리케이션의 로그인 페이지를 생성하고 보안을 구성하기에 앞서 먼저 할 일이 있다. 한 명 이상의 사용자를 처리할 수 있도록 사용자 정보를 유지, 관리하는 **사용자 스토어** 를 구성하는 것이다. 스프링 시큐리티에서는 여러 가지의 사용자 스토어 구성 방법을 제공한다.

- 인메모리(in-memory) 사용자 스토어
- JDBC 기반 사용자 스토어
- LDAP 기반 사용자 스토어
- 커스텀 사용자 명세 서비스

잠시 앞에서 작성한 SecurityConfig 클래스를 다시 살펴보자. 이는 보안 구성 클래스인 WebSecurityConfigurerAdapter의 서브 클래스이다. 그리고 두 개의 configure() 메서드를 오버라이딩 하고 있다. **configure(HttpSecurity)** 는 **HTTP 보안을 구성하는 메서드** 이다. 그리고 **configure(AuthenticationManagerBuilder)** 는 **사용자 인증 정보를 구성하는 메서드** 이며, 위의 사용자 스토어 중 어떤 것을 선택하든 이 메서드에서 구성한다. 

우선, configure(AuthenticationManagerBuilder) 메서드를 오버라이딩하여 **사용자 스토어를 구성** 하는 방법부터 알아보자.

```java
@Override
public void configure(AuthenticationManagerBuilder auth) throws Exception {
    ...
}
```

이 configure() 메서드에는 인증을 하기 위해 사용자를 찾는 방법을 지정하는 코드를 작성해야 한다. 이때 인자로 전달된 AuthenticationManagerBuilder를 사용한다. 인메모리 사용자 스토어를 구현하는 방법은 다음과 같다.

## 4.2.1 인메모리 사용자 스토어(p123~125)

사용자 정보를 유지 및 관리할 수 있는 곳 중 하나가 메모리다. 만약 변경이 필요 없는 사용자만 미리 정해 놓고 애플리케이션을 사용한다면 아예 보안 구성 코드 내부에 사용자들을 정의할 수 있을 것이다.

예를 들어, "user1"과 "user2"라는 사용자를 인메모리 사용자 스토어에 구성하는 방법을 보여준다. 

```java
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
        .withUser("user1")
        .password("{noop}password1")
        .authorities("ROLE_USER")
        .and()
        .withUser("user2")
        .password("{noop}password2")
        .authorities("ROLE_USER");
}
```

타코 애플리케이션이 실행되는 상태에서 http://localhost:8080/design에 접속하면 로그인 대화상자가 나타난다(웹 브라우저의 프라이버시 모드에서 실행하자). 사용자 이름에 "user1", 비밀번호에 "password1"을 입력하고 로그인 버튼을 클릭하면 정상적으로 인증되어 타코 디자인 폼이 나타날 것이다. 만약 보안과 관련하여 변경을 했을 때는 현재 창을 닫고 다시 프라이버시 모드로 새 창을 열어 테스트하는 것이 좋다.

AuthenticationManagerBuilder는 인증 명세를 구성하기 위해 빌더 형태의 API를 사용한다. 이때 **inMemoryAuthentication()** 메서드를 사용하여 보안 구성 자체에 사용자 정보를 직접 지정할 수 있다.

withUser()를 호출하면 해당 사용자의 구성이 시작되며, 이때 사용자 이름(username)을 인자로 전달한다. 한편 비밀번호(password)와 부여 권한(granted authority)는 각각 password()와 authorities() 메서드의 인자로 전달하여 호출한다.(.authorities("ROLE_USER") 대신 .roles("USER")를 사용해도 된다). 그리고 and() 메서드로 연속해서 withUser()를 호출하여 여러 사용자를 지정할 수 있다. 

스프링 5부터는 반드시 비밀번호를 암호화해야 한다. 만약 password() 메서드를 호출하여 암호화하지 않으면 접근 거부(HTTP 403) 또는 Internal Server Error(HTTP 500)가 발생한다. 그러나 인메모리 사용자 스토어의 간단한 테스트를 위해 위 코드에서는 {noop}를 지정하여 비밀번호를 암호화하지 않았다.

인메모리 사용자 스토어는 테스트 목적이나 간단한 애플리케이션은 편리하다. 하지만 사용자 정보 추가 및 변경이 쉽지 않다. 이런 점 때문에 고객 스스로 사용자로 등록하고 정보를 변경하는 타코 클라우드 애플리케이션에서는 인메모리 사용자 스토어가 적합하지 않다. 다음에서는 데이터베이스로 지원되는 사용자 스토어를 알아보도록 하자.

## 4.2.2 JDBC 기반의 사용자 스토어(p125)

사용자 정보는 관계형 데이터베이스로 유지 및 관리되는 경우가 많기 때문에 JDBC 기반의 사용자 스토어가 적합해 보인다. 다음에서는 관계형 데이터베이스에 유지되는 사용자 정보를 인증하기 위해 JDBC를 사용하여 스프링 시큐리티를 구성하는 방법을 보여준다.

```JAVA
...
import javax.sql.DateSource;
...

@Autowired
DataSource dataSource;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource);
}
```

configure()에서는 AuthenticationManagerBuilder의 jdbcAuthentication()을 호출한다. 이때 데이터베이스를 접근하는 방법을 알 수 있도록 dataSource() 메서드를 호출하여 DataSource도 설정해주어야 한다. 여기에서는 @Autowired 애노테이션을 지정했기 때문에 DataSource가 자동으로 주입된다.

## 스프링 시큐리티의 기본 사용자 쿼리를 대체하기(p125~129)

스프링 시큐리티의 사용자 정보 데이터베이스 스키마를 사용할 때는 방금 전에 작성한 configure() 메서드의 코드로도 충분하다. 사용자 정보를 저장하는 테이블과 열이 정해져 있고 쿼리가 미리 생성되어 있기 때문이다. 즉, 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서는 기본적으로 다음 쿼리를 수행한다.

```java
public static final String DEF_USERS_BY_USERNAME_QUERY = 
    		"select username, password, enabled " +
    		"from users " +
    		"where username = ?";

public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
    		"select username, authority " +
    		"from authorities " +
    		"where username = ?";

public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = 
    		"select g.id, g.group_name, ga.authority " +
    		"from authorities g, group_members gm, group_authorities ga " +
    		"where gm.username = ? " +
    		"and g.id = ga.group_id " +
    		"and g.id = gm.group_id ";
```

이것을 보면 내부적으로 기본 생성되는 테이블과 열의 이름을 알 수 있다. 사용자 정보는 **users 테이블** 에, 권한은 **authorities 테이블** 에, 그룹의 사용자는 **group_members 테이블** 에, 그룹의 권한은 **group_authorities 테이블** 에 있다. 

첫 번째 쿼리에서는 해당 사용자의 이름(username), 비밀번호(password), 사용 가능한 사용자인지를 나타내는 활성화 여부(enabled)를 검색한다. 이 정보는 사용자 인증에 사용된다.

그다음 쿼리에서는 해당 사용자에게 부여된 권한을 찾는다. 

마지막 쿼리에서는 해당 사용자가 속한 그룹과 그룹 권한을 찾는다.

스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하려면 관련 테이블을 생성하고 사용자 데이터를 추가해야 한다. 우선, 데이터베이스 스키마를 생성하는 SQL은 다음과 같다.

```SQL
drop table if exists users;
drop table if exists authorities;
drop table if exists ix_auth_username;

create table if not exists users (
	username varchar2(50) not null primary key,
	password varchar2(50) not null,
	enabled char(1) default '1');
	
create table if not exists authorities (
	username varchar2(50) not null,
	authority varchar2(50) not null,
	constraint fk_authorities_users
    	foreign key(username) references users(username));
    	
create unique index ix_auth_username
	on authorities (username, authority);
```

이 SQL은 스프링 시큐리티에 사전 지정된 사용자 및 권한 테이블과 동일한 테이블을 생성한다.

다음은 사용자 데이터를 추가하는 SQL이다.

```SQL
insert into users (username, password) values ('user1', 'password1');
insert into users (username, password) values ('user2', 'password2');

insert into authorities (username, authority)
	values ('user1', 'ROLE_USER');
insert into authorities (username, authority)
	values ('user2', 'ROLE_USER');
	
commit;
```

스프링 5 버전 이상에서 위의 내용대로 사용자 데이터를 추가하려면 비밀번호를 암호화해주어야 한다. 암호화하는  방법은 추후 살펴보기로 하자.

지금까지 한 내용으로 스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하고 사용자 데이터도 저장했다면 이대로 사용할 수 있다. 그러나 스프링 시큐리티의 것과 다른 데이터베이스(예를 들어, 테이블이나 열의 이름이 다를 때)를 사용한다면, 다음과 같이 스프링 시큐리티의 SQL 쿼리를 직접 대체할 수 있다. 

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?");
}
```

이 쿼리에서 사용하는 테이블의 이름은 스프링 시큐리티의 기본 데이터베이스 테이블과 달라도 된다(여기에서는 기본 데이터베이스 테이블을 그냥 사용하였다). 그러나 테이블이 갖는 열의 데이터 타입과 길이는 일치해야 한다.

여기에서는 또한 usersByUsernameQuery()와 authoritiesByUsernameQuery() 메서드를 사용하여 사용자 정보와 권한 쿼리만을 대체하였다. 하지만 groupAuthoritiesByUsername()을 호출하여 그룹 권한 쿼리도 대체할 수 있다.

스프링 시큐리티의 기본 SQL 쿼리를 직접 대체할 때는 다음 사항을 지켜야 한다. 매개변수(where 절에 사용됨)는 하나이며, username이어야 한다. 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다. 사용자 권한 쿼리에서는 해당 사용자 이름(username)과 부여된 권한(authority)을 포함하는  0개 또는 다수의 행을 반환할 수 있다. 그리고 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름(group_name), 권한(authority) 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

## 스프링 시큐리티의 기본 사용자 쿼리를 대체하기(p125~129)

스프링 시큐리티의 사용자 정보 데이터베이스 스키마를 사용할 때는 방금 전에 작성한 configure() 메서드의 코드로도 충분하다. 사용자 정보를 저장하는 테이블과 열이 정해져 있고 쿼리가 미리 생성되어 있기 때문이다. 즉, 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서는 기본적으로 다음 쿼리를 수행한다.

```java
public static final String DEF_USERS_BY_USERNAME_QUERY = 
    		"select username, password, enabled " +
    		"from users " +
    		"where username = ?";

public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
    		"select username, authority " +
    		"from authorities " +
    		"where username = ?";

public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = 
    		"select g.id, g.group_name, ga.authority " +
    		"from authorities g, group_members gm, group_authorities ga " +
    		"where gm.username = ? " +
    		"and g.id = ga.group_id " +
    		"and g.id = gm.group_id ";
```

이것을 보면 내부적으로 기본 생성되는 테이블과 열의 이름을 알 수 있다. 사용자 정보는 **users 테이블** 에, 권한은 **authorities 테이블** 에, 그룹의 사용자는 **group_members 테이블** 에, 그룹의 권한은 **group_authorities 테이블** 에 있다. 

첫 번째 쿼리에서는 해당 사용자의 이름(username), 비밀번호(password), 사용 가능한 사용자인지를 나타내는 활성화 여부(enabled)를 검색한다. 이 정보는 사용자 인증에 사용된다.

그다음 쿼리에서는 해당 사용자에게 부여된 권한을 찾는다. 

마지막 쿼리에서는 해당 사용자가 속한 그룹과 그룹 권한을 찾는다.

스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하려면 관련 테이블을 생성하고 사용자 데이터를 추가해야 한다. 우선, 데이터베이스 스키마를 생성하는 SQL은 다음과 같다.

```SQL
drop table if exists users;
drop table if exists authorities;
drop table if exists ix_auth_username;

create table if not exists users (
	username varchar2(50) not null primary key,
	password varchar2(50) not null,
	enabled char(1) default '1');
	
create table if not exists authorities (
	username varchar2(50) not null,
	authority varchar2(50) not null,
	constraint fk_authorities_users
    	foreign key(username) references users(username));
    	
create unique index ix_auth_username
	on authorities (username, authority);
```

이 SQL은 스프링 시큐리티에 사전 지정된 사용자 및 권한 테이블과 동일한 테이블을 생성한다.

다음은 사용자 데이터를 추가하는 SQL이다.

```SQL
insert into users (username, password) values ('user1', 'password1');
insert into users (username, password) values ('user2', 'password2');

insert into authorities (username, authority)
	values ('user1', 'ROLE_USER');
insert into authorities (username, authority)
	values ('user2', 'ROLE_USER');
	
commit;
```

스프링 5 버전 이상에서 위의 내용대로 사용자 데이터를 추가하려면 비밀번호를 암호화해주어야 한다. 암호화하는  방법은 추후 살펴보기로 하자.

지금까지 한 내용으로 스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하고 사용자 데이터도 저장했다면 이대로 사용할 수 있다. 그러나 스프링 시큐리티의 것과 다른 데이터베이스(예를 들어, 테이블이나 열의 이름이 다를 때)를 사용한다면, 다음과 같이 스프링 시큐리티의 SQL 쿼리를 직접 대체할 수 있다. 

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?");
}
```

이 쿼리에서 사용하는 테이블의 이름은 스프링 시큐리티의 기본 데이터베이스 테이블과 달라도 된다(여기에서는 기본 데이터베이스 테이블을 그냥 사용하였다). 그러나 테이블이 갖는 열의 데이터 타입과 길이는 일치해야 한다.

여기에서는 또한 usersByUsernameQuery()와 authoritiesByUsernameQuery() 메서드를 사용하여 사용자 정보와 권한 쿼리만을 대체하였다. 하지만 groupAuthoritiesByUsername()을 호출하여 그룹 권한 쿼리도 대체할 수 있다.

스프링 시큐리티의 기본 SQL 쿼리를 직접 대체할 때는 다음 사항을 지켜야 한다. 매개변수(where 절에 사용됨)는 하나이며, username이어야 한다. 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다. 사용자 권한 쿼리에서는 해당 사용자 이름(username)과 부여된 권한(authority)을 포함하는  0개 또는 다수의 행을 반환할 수 있다. 그리고 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름(group_name), 권한(authority) 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

## 암호화된 비밀번호 사용하기(p129~132)

비밀번호를 데이터베이스에 저장할 때와 사용자가 로그인을 위해 비밀번호를 입력할 때 모두 같은 암호화 알고리즘을 사용해서 암호화해야 한다.

비밀번호를 암호화할 때는 다음과 같이 passwordEncoder() 메서드를 호출하여 비밀번호 인코더(encoder)를 지정한다.

```java
...
import org.sprinframework.security.crypto.brypt.BCryptPasswordEncoder;
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?")
        .passwordEncoder(new BCryptPasswordEncoder());
}
```

 passwordEncoder() 메서드는 스프링 시큐리티의 PasswordEncoder 인터페이스를 구현하는 어떤 객체도 인자로 받을 수 있다. 

암호화 알고리즘을 구현한 스프링 시큐리티의 모듈에는 다음과 같은 구현 클래스가 포함되어 있다.

- BCryptPasswordEncoder: bcrypt를 해싱 암호화한다.
- NoOpPasswordEncoder: 암호화하지 않는다.
- Pbkdf2PasswordEncoder: PBKDF2를 암호화한다.
- SCryptPasswordEncoder: scrypt를 해싱 암호화한다.
- StandardPasswordEncoder: SHA-256을 해싱 암호화한다.

참고로 PasswordEncoder 인터페이스는 다음과 같이 정의되어 있다.

```java
public interface PasswordEncoder {
    String encode(CharSequence rawPassword);
    boolean matches(CharSequence rawPassword, String encodedPassword);
}
```

어떤 비밀번호 인코더를 사용하든, 일단 암호화되어 데이터베이스에 저장된 비밀번호는 암호가 해독되지 않는다. 대신 로그인 시 사용자가 입력한 비밀번호와 동일한 알고리즘을 사용해서 암호화된다. 그다음에 데이터베이스의 암호화된 비밀번호와 비교되는데 이는 PasswordEncoder의 matches() 메서드에서 수행되어야 한다.

한편 지금까지 진행한 작업으로 http://localhost:8080/design에 접속하여 로그인을 시도해도 로그인이 정상적으로 진행되지는 않는다. 왜냐하면 데이터베이스에 저장된 비밀번호는 암호화되지 않았지만, 로그인 대화상자에 입력된 비밀번호는 암호화되어 두 값이 다른 것으로 간주되기 때문이다. 인증을 위해 그냥 간단한 테스트를 진행하고자 한다면, 역설적이지만 PasswordEncoder 인터페이스를 구현하되 암호화를 하지 않는 클래스(가칭 NoEncodingPassswordEncoder)를 임시로 작성하고 사용해야 한다. 자세한 방법은 본서를 직접 참조하도록 하자.  

다음에서는 JDBC 기반의 jdbcAuthentication()을 대신할 다른 인증 방법을 사용할 것이다. 그 전에 또 다른 사용자 스토어인 LDAP(Lightweight Directory Access Protocol)를 알아보도록 하자.
