# Chapter 04. 스프링 시큐리티

소프트웨어 개발자로써 우리느 애플리케이션에 있는 정보를 보호하는 조치를 해야 한다. 앞으로 **스프링 시큐리티를 자동 구성** 하는 방법, **커스텀 사용자 스토리지** 를 정의하는 방법 등을 배우고, **커스텀 로그인 페이지** 를 만들어볼 것이다. 또한 **CSRF 공격** 을 막아보고, **사용자를 파악** 해보는 방법을 살펴볼 것이다.

## 4.1 스프링 시큐리티 활성화하기(p117~120)

스프링 애플리케이션의 보안에서 가장 먼저 할 일은 **스프링 부트 보안 스타터 의존성** 을 빌드 명세에 추가하는 것이다. 아래 pom.xml 파일에서 추가하는 첫 번째 `<dependency>` 항목은 스프링 부트 보안 스타터 의존성이고, 두 번째는 보안 테스트 의존성이다.

```xml
...
<dependencies>
	...
    <dependency>
    	<groupdId>org.springframework.boot</groupdId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <dependency>
    	<gorupId>org.springframework.security</gorupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

놀랍게도 방금 추가한 의존성이 스프링 애플리케이션을 안전하게 하기 위해 필요한 전부이다. 애플리케이션이 시작되면 스프링이 우리 프로젝트의 classpath에 있는 스프링 시큐리티 라이브러리를 찾아 기본적인 보안 구성을 설정한다.

어떻게 설정해 주는지 확인하려면 애플리케이션을 시작한 후, 웹 브라우저에서 홈페이지(http://localhost:8080)이나 타코 디자인 페이지(http://localhost:8080/design)에 접속해 보자. 그러면 스프링 시큐리티에서 제공하는 HTTP 기본 인증 대화상자가 나타난다.

기본 인증 대화상자에서 Username 필드에 "user"라고 입력한다. Password는 무작위로 자동 생성되어 애플리케이션 로그 파일에 수록된다. STS를 사용하는 경우 콘솔 창에 다음과 같은 로그 항목이 나타난다.

```
Using generated security password: 6838886b-edb5-40d8-bc45-395ba25a79e4
```

뒤쪽 36자리의 비밀번호를 마우스로 선택하여 복사한 후 Password 필드에 붙여넣기 하고 Sign in 버튼을 클릭하면 로그인된다. 그러면 애플리케이션을 사용할 수 있는 권한이 부여되어 우리가 접속한 페이지가 나타난다. 스프링의 username(사용자 이름)은 사용자 id를 의미한다.

지금부터는 스프링 시큐리티의 보안 자동 구성이 어떻게 제공되는지 알아보자.

먼저 보안 스타터를 프로젝트 빌드 파일에 추가만 할 경우 다음의 보안 구성이 제공된다.

- 모든 HTTP 요청 경로는 인증(authentication) 되어야 한다.
- 어떤 특정 역할이나 권한이 없다.
- 로그인 페이지가 따로 없다.
- 스프링 시큐리티의 HTTP 기본 인증(앞서 했던 인증)을 사용해서 인증된다.
- 사용자는 user 이름으로 하나만 존재한다. 비밀번호는 암호화해준다.

타코 클라우드 애플리케이션을 비롯하여 자신만의 애플리케이션을 만들 땐 보안을 제대로 구축하기 위해 더 많은 작업이 필요하며, 최소한 다음 기능을 할 수 있도록 스프링 시큐리티를 구성해야 한다.

-  스프링 시큐리티의 HTTP 인증 대화상자 대신 우리의 로그인 페이지로 인증한다.
- 다수의 사용자를 제공하며, 새로운 타코 클라우드 고객이 사용자로 등록할 수 있는 페이지가 있어야 한다.
- 서로 다른 HTTP 요청 경로마다 서로 다른 보안 규칙을 적용한다. 예를 들어 홈페이지와 사용자 등록 페이지는 인증이 필요하지 않다.

위와 같은 보안 요구를 충족하기 위해서 스프링 자동-구성이 하는 것을 대체하는 작업을 해야 한다. 우선 한 명 이상의 사용자를 가질 수 있도록 타코 클라우드에 적합한 사용자 스토어(store)를 구성해보자.

## 4.2 스프링 시큐리티 구성하기(p120~123)

우선 자바 기반으로 기본 구성 클래스를 작성해보자.

```java
package tacos.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation
    	.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation
    	.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web
    	.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web
    	.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protectesd void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/design", "/orders")
            .access("hasRole('ROLE_USER')")
            .antMatchers("/", "/**").access("permitAll")
            .and()
            .httpBasic();
    }
    
    @Override
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user1")
            .password("{noop}password1")
            .authorities("ROLE_USER")
            .and()
            .withUser("user2")
            .password("{noop}password2")
            .authorities("ROLE_USER");
    }
}
```

SecurityConfig 클래스는 간단히 말해 사용자의 HTTP 요청 경로에 대해 접근 제한과 같은 보안 관련 처리를 우리가 원하는대로 할 수 있게 해준다. 자세한 내용은 진도를 나간 이후에 알게 될 것이다.  

일단, 타코 클라우드 애플리케이션을 실행하고 웹 브라우저에서 http://localhost:8080으로 접속하자.  SecurityConfig 클래스의 configure() 메서드에서 모든 사용자의 홈페이지 접근을 허용했기 때문에 홈페이지가 바로 나타날 것이다. 그다음에 http://localhost:8080/design에 접속해 보자. 이번에는 스프링 시큐리티의 HTTP 기본 인증 대화상자 대신 다른 HTTP 로그인 대화상자가 나타날 것이다. 

사용자 이름에는 "user1", 비밀번호 필드에는 "password1"을 입력하고 로그인을 클릭하면 타코 디자인 폼이 나타날 것이다. 우리는 여기서 더 나아가 실제로 애플리케이션에서 사용할 만한 로그인 페이지를 새로 생성할 것이다. (앞의 코드에서는 비밀번호를 암호화하지 않았지만 실제로는 반드시 해야 한다.)

타코 클라우드 애플리케이션의 로그인 페이지를 생성하고 보안을 구성하기에 앞서 먼저 할 일이 있다. 한 명 이상의 사용자를 처리할 수 있도록 사용자 정보를 유지, 관리하는 **사용자 스토어** 를 구성하는 것이다. 스프링 시큐리티에서는 여러 가지의 사용자 스토어 구성 방법을 제공한다.

- 인메모리(in-memory) 사용자 스토어
- JDBC 기반 사용자 스토어
- LDAP 기반 사용자 스토어
- 커스텀 사용자 명세 서비스

잠시 앞에서 작성한 SecurityConfig 클래스를 다시 살펴보자. 이는 보안 구성 클래스인 WebSecurityConfigurerAdapter의 서브 클래스이다. 그리고 두 개의 configure() 메서드를 오버라이딩 하고 있다. **configure(HttpSecurity)** 는 **HTTP 보안을 구성하는 메서드** 이다. 그리고 **configure(AuthenticationManagerBuilder)** 는 **사용자 인증 정보를 구성하는 메서드** 이며, 위의 사용자 스토어 중 어떤 것을 선택하든 이 메서드에서 구성한다. 

우선, configure(AuthenticationManagerBuilder) 메서드를 오버라이딩하여 **사용자 스토어를 구성** 하는 방법부터 알아보자.

```java
@Override
public void configure(AuthenticationManagerBuilder auth) throws Exception {
    ...
}
```

이 configure() 메서드에는 인증을 하기 위해 사용자를 찾는 방법을 지정하는 코드를 작성해야 한다. 이때 인자로 전달된 AuthenticationManagerBuilder를 사용한다. 인메모리 사용자 스토어를 구현하는 방법은 다음과 같다.

## 4.2.1 인메모리 사용자 스토어(p123~125)

사용자 정보를 유지 및 관리할 수 있는 곳 중 하나가 메모리다. 만약 변경이 필요 없는 사용자만 미리 정해 놓고 애플리케이션을 사용한다면 아예 보안 구성 코드 내부에 사용자들을 정의할 수 있을 것이다.

예를 들어, "user1"과 "user2"라는 사용자를 인메모리 사용자 스토어에 구성하는 방법을 보여준다. 

```java
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
        .withUser("user1")
        .password("{noop}password1")
        .authorities("ROLE_USER")
        .and()
        .withUser("user2")
        .password("{noop}password2")
        .authorities("ROLE_USER");
}
```

타코 애플리케이션이 실행되는 상태에서 http://localhost:8080/design에 접속하면 로그인 대화상자가 나타난다(웹 브라우저의 프라이버시 모드에서 실행하자). 사용자 이름에 "user1", 비밀번호에 "password1"을 입력하고 로그인 버튼을 클릭하면 정상적으로 인증되어 타코 디자인 폼이 나타날 것이다. 만약 보안과 관련하여 변경을 했을 때는 현재 창을 닫고 다시 프라이버시 모드로 새 창을 열어 테스트하는 것이 좋다.

AuthenticationManagerBuilder는 인증 명세를 구성하기 위해 빌더 형태의 API를 사용한다. 이때 **inMemoryAuthentication()** 메서드를 사용하여 보안 구성 자체에 사용자 정보를 직접 지정할 수 있다.

withUser()를 호출하면 해당 사용자의 구성이 시작되며, 이때 사용자 이름(username)을 인자로 전달한다. 한편 비밀번호(password)와 부여 권한(granted authority)는 각각 password()와 authorities() 메서드의 인자로 전달하여 호출한다.(.authorities("ROLE_USER") 대신 .roles("USER")를 사용해도 된다). 그리고 and() 메서드로 연속해서 withUser()를 호출하여 여러 사용자를 지정할 수 있다. 

스프링 5부터는 반드시 비밀번호를 암호화해야 한다. 만약 password() 메서드를 호출하여 암호화하지 않으면 접근 거부(HTTP 403) 또는 Internal Server Error(HTTP 500)가 발생한다. 그러나 인메모리 사용자 스토어의 간단한 테스트를 위해 위 코드에서는 {noop}를 지정하여 비밀번호를 암호화하지 않았다.

인메모리 사용자 스토어는 테스트 목적이나 간단한 애플리케이션은 편리하다. 하지만 사용자 정보 추가 및 변경이 쉽지 않다. 이런 점 때문에 고객 스스로 사용자로 등록하고 정보를 변경하는 타코 클라우드 애플리케이션에서는 인메모리 사용자 스토어가 적합하지 않다. 다음에서는 데이터베이스로 지원되는 사용자 스토어를 알아보도록 하자.

## 4.2.2 JDBC 기반의 사용자 스토어(p125)

사용자 정보는 관계형 데이터베이스로 유지 및 관리되는 경우가 많기 때문에 JDBC 기반의 사용자 스토어가 적합해 보인다. 다음에서는 관계형 데이터베이스에 유지되는 사용자 정보를 인증하기 위해 JDBC를 사용하여 스프링 시큐리티를 구성하는 방법을 보여준다.

```JAVA
...
import javax.sql.DateSource;
...

@Autowired
DataSource dataSource;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource);
}
```

configure()에서는 AuthenticationManagerBuilder의 jdbcAuthentication()을 호출한다. 이때 데이터베이스를 접근하는 방법을 알 수 있도록 dataSource() 메서드를 호출하여 DataSource도 설정해주어야 한다. 여기에서는 @Autowired 애노테이션을 지정했기 때문에 DataSource가 자동으로 주입된다.

## 스프링 시큐리티의 기본 사용자 쿼리를 대체하기(p125~129)

스프링 시큐리티의 사용자 정보 데이터베이스 스키마를 사용할 때는 방금 전에 작성한 configure() 메서드의 코드로도 충분하다. 사용자 정보를 저장하는 테이블과 열이 정해져 있고 쿼리가 미리 생성되어 있기 때문이다. 즉, 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서는 기본적으로 다음 쿼리를 수행한다.

```java
public static final String DEF_USERS_BY_USERNAME_QUERY = 
    		"select username, password, enabled " +
    		"from users " +
    		"where username = ?";

public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
    		"select username, authority " +
    		"from authorities " +
    		"where username = ?";

public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = 
    		"select g.id, g.group_name, ga.authority " +
    		"from authorities g, group_members gm, group_authorities ga " +
    		"where gm.username = ? " +
    		"and g.id = ga.group_id " +
    		"and g.id = gm.group_id ";
```

이것을 보면 내부적으로 기본 생성되는 테이블과 열의 이름을 알 수 있다. 사용자 정보는 **users 테이블** 에, 권한은 **authorities 테이블** 에, 그룹의 사용자는 **group_members 테이블** 에, 그룹의 권한은 **group_authorities 테이블** 에 있다. 

첫 번째 쿼리에서는 해당 사용자의 이름(username), 비밀번호(password), 사용 가능한 사용자인지를 나타내는 활성화 여부(enabled)를 검색한다. 이 정보는 사용자 인증에 사용된다.

그다음 쿼리에서는 해당 사용자에게 부여된 권한을 찾는다. 

마지막 쿼리에서는 해당 사용자가 속한 그룹과 그룹 권한을 찾는다.

스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하려면 관련 테이블을 생성하고 사용자 데이터를 추가해야 한다. 우선, 데이터베이스 스키마를 생성하는 SQL은 다음과 같다.

```SQL
drop table if exists users;
drop table if exists authorities;
drop table if exists ix_auth_username;

create table if not exists users (
	username varchar2(50) not null primary key,
	password varchar2(50) not null,
	enabled char(1) default '1');
	
create table if not exists authorities (
	username varchar2(50) not null,
	authority varchar2(50) not null,
	constraint fk_authorities_users
    	foreign key(username) references users(username));
    	
create unique index ix_auth_username
	on authorities (username, authority);
```

이 SQL은 스프링 시큐리티에 사전 지정된 사용자 및 권한 테이블과 동일한 테이블을 생성한다.

다음은 사용자 데이터를 추가하는 SQL이다.

```SQL
insert into users (username, password) values ('user1', 'password1');
insert into users (username, password) values ('user2', 'password2');

insert into authorities (username, authority)
	values ('user1', 'ROLE_USER');
insert into authorities (username, authority)
	values ('user2', 'ROLE_USER');
	
commit;
```

스프링 5 버전 이상에서 위의 내용대로 사용자 데이터를 추가하려면 비밀번호를 암호화해주어야 한다. 암호화하는  방법은 추후 살펴보기로 하자.

지금까지 한 내용으로 스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하고 사용자 데이터도 저장했다면 이대로 사용할 수 있다. 그러나 스프링 시큐리티의 것과 다른 데이터베이스(예를 들어, 테이블이나 열의 이름이 다를 때)를 사용한다면, 다음과 같이 스프링 시큐리티의 SQL 쿼리를 직접 대체할 수 있다. 

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?");
}
```

이 쿼리에서 사용하는 테이블의 이름은 스프링 시큐리티의 기본 데이터베이스 테이블과 달라도 된다(여기에서는 기본 데이터베이스 테이블을 그냥 사용하였다). 그러나 테이블이 갖는 열의 데이터 타입과 길이는 일치해야 한다.

여기에서는 또한 usersByUsernameQuery()와 authoritiesByUsernameQuery() 메서드를 사용하여 사용자 정보와 권한 쿼리만을 대체하였다. 하지만 groupAuthoritiesByUsername()을 호출하여 그룹 권한 쿼리도 대체할 수 있다.

스프링 시큐리티의 기본 SQL 쿼리를 직접 대체할 때는 다음 사항을 지켜야 한다. 매개변수(where 절에 사용됨)는 하나이며, username이어야 한다. 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다. 사용자 권한 쿼리에서는 해당 사용자 이름(username)과 부여된 권한(authority)을 포함하는  0개 또는 다수의 행을 반환할 수 있다. 그리고 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름(group_name), 권한(authority) 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

## 스프링 시큐리티의 기본 사용자 쿼리를 대체하기(p125~129)

스프링 시큐리티의 사용자 정보 데이터베이스 스키마를 사용할 때는 방금 전에 작성한 configure() 메서드의 코드로도 충분하다. 사용자 정보를 저장하는 테이블과 열이 정해져 있고 쿼리가 미리 생성되어 있기 때문이다. 즉, 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서는 기본적으로 다음 쿼리를 수행한다.

```java
public static final String DEF_USERS_BY_USERNAME_QUERY = 
    		"select username, password, enabled " +
    		"from users " +
    		"where username = ?";

public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
    		"select username, authority " +
    		"from authorities " +
    		"where username = ?";

public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = 
    		"select g.id, g.group_name, ga.authority " +
    		"from authorities g, group_members gm, group_authorities ga " +
    		"where gm.username = ? " +
    		"and g.id = ga.group_id " +
    		"and g.id = gm.group_id ";
```

이것을 보면 내부적으로 기본 생성되는 테이블과 열의 이름을 알 수 있다. 사용자 정보는 **users 테이블** 에, 권한은 **authorities 테이블** 에, 그룹의 사용자는 **group_members 테이블** 에, 그룹의 권한은 **group_authorities 테이블** 에 있다. 

첫 번째 쿼리에서는 해당 사용자의 이름(username), 비밀번호(password), 사용 가능한 사용자인지를 나타내는 활성화 여부(enabled)를 검색한다. 이 정보는 사용자 인증에 사용된다.

그다음 쿼리에서는 해당 사용자에게 부여된 권한을 찾는다. 

마지막 쿼리에서는 해당 사용자가 속한 그룹과 그룹 권한을 찾는다.

스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하려면 관련 테이블을 생성하고 사용자 데이터를 추가해야 한다. 우선, 데이터베이스 스키마를 생성하는 SQL은 다음과 같다.

```SQL
drop table if exists users;
drop table if exists authorities;
drop table if exists ix_auth_username;

create table if not exists users (
	username varchar2(50) not null primary key,
	password varchar2(50) not null,
	enabled char(1) default '1');
	
create table if not exists authorities (
	username varchar2(50) not null,
	authority varchar2(50) not null,
	constraint fk_authorities_users
    	foreign key(username) references users(username));
    	
create unique index ix_auth_username
	on authorities (username, authority);
```

이 SQL은 스프링 시큐리티에 사전 지정된 사용자 및 권한 테이블과 동일한 테이블을 생성한다.

다음은 사용자 데이터를 추가하는 SQL이다.

```SQL
insert into users (username, password) values ('user1', 'password1');
insert into users (username, password) values ('user2', 'password2');

insert into authorities (username, authority)
	values ('user1', 'ROLE_USER');
insert into authorities (username, authority)
	values ('user2', 'ROLE_USER');
	
commit;
```

스프링 5 버전 이상에서 위의 내용대로 사용자 데이터를 추가하려면 비밀번호를 암호화해주어야 한다. 암호화하는  방법은 추후 살펴보기로 하자.

지금까지 한 내용으로 스프링 시큐리티에 사전 지정된 데이터베이스 테이블과 SQL 쿼리를 사용하고 사용자 데이터도 저장했다면 이대로 사용할 수 있다. 그러나 스프링 시큐리티의 것과 다른 데이터베이스(예를 들어, 테이블이나 열의 이름이 다를 때)를 사용한다면, 다음과 같이 스프링 시큐리티의 SQL 쿼리를 직접 대체할 수 있다. 

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?");
}
```

이 쿼리에서 사용하는 테이블의 이름은 스프링 시큐리티의 기본 데이터베이스 테이블과 달라도 된다(여기에서는 기본 데이터베이스 테이블을 그냥 사용하였다). 그러나 테이블이 갖는 열의 데이터 타입과 길이는 일치해야 한다.

여기에서는 또한 usersByUsernameQuery()와 authoritiesByUsernameQuery() 메서드를 사용하여 사용자 정보와 권한 쿼리만을 대체하였다. 하지만 groupAuthoritiesByUsername()을 호출하여 그룹 권한 쿼리도 대체할 수 있다.

스프링 시큐리티의 기본 SQL 쿼리를 직접 대체할 때는 다음 사항을 지켜야 한다. 매개변수(where 절에 사용됨)는 하나이며, username이어야 한다. 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다. 사용자 권한 쿼리에서는 해당 사용자 이름(username)과 부여된 권한(authority)을 포함하는  0개 또는 다수의 행을 반환할 수 있다. 그리고 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름(group_name), 권한(authority) 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

## 암호화된 비밀번호 사용하기(p129~132)

비밀번호를 데이터베이스에 저장할 때와 사용자가 로그인을 위해 비밀번호를 입력할 때 모두 같은 암호화 알고리즘을 사용해서 암호화해야 한다.

비밀번호를 암호화할 때는 다음과 같이 passwordEncoder() 메서드를 호출하여 비밀번호 인코더(encoder)를 지정한다.

```java
...
import org.sprinframework.security.crypto.brypt.BCryptPasswordEncoder;
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .jdbcAuthentication()
        .dataSource(dataSource)
        .usersByUsernameQuery(
    		"select username, password, enabled from users " +
    		"where username=?")
        .authoritiesByUsernameQuery(
    		"select useranme, authority from authorities " +
    		"where username=?")
        .passwordEncoder(new BCryptPasswordEncoder());
}
```

 passwordEncoder() 메서드는 스프링 시큐리티의 PasswordEncoder 인터페이스를 구현하는 어떤 객체도 인자로 받을 수 있다. 

암호화 알고리즘을 구현한 스프링 시큐리티의 모듈에는 다음과 같은 구현 클래스가 포함되어 있다.

- BCryptPasswordEncoder: bcrypt를 해싱 암호화한다.
- NoOpPasswordEncoder: 암호화하지 않는다.
- Pbkdf2PasswordEncoder: PBKDF2를 암호화한다.
- SCryptPasswordEncoder: scrypt를 해싱 암호화한다.
- StandardPasswordEncoder: SHA-256을 해싱 암호화한다.

참고로 PasswordEncoder 인터페이스는 다음과 같이 정의되어 있다.

```java
public interface PasswordEncoder {
    String encode(CharSequence rawPassword);
    boolean matches(CharSequence rawPassword, String encodedPassword);
}
```

어떤 비밀번호 인코더를 사용하든, 일단 암호화되어 데이터베이스에 저장된 비밀번호는 암호가 해독되지 않는다. 대신 로그인 시 사용자가 입력한 비밀번호와 동일한 알고리즘을 사용해서 암호화된다. 그다음에 데이터베이스의 암호화된 비밀번호와 비교되는데 이는 PasswordEncoder의 matches() 메서드에서 수행되어야 한다.

한편 지금까지 진행한 작업으로 http://localhost:8080/design에 접속하여 로그인을 시도해도 로그인이 정상적으로 진행되지는 않는다. 왜냐하면 데이터베이스에 저장된 비밀번호는 암호화되지 않았지만, 로그인 대화상자에 입력된 비밀번호는 암호화되어 두 값이 다른 것으로 간주되기 때문이다. 인증을 위해 그냥 간단한 테스트를 진행하고자 한다면, 역설적이지만 PasswordEncoder 인터페이스를 구현하되 암호화를 하지 않는 클래스(가칭 NoEncodingPassswordEncoder)를 임시로 작성하고 사용해야 한다. 자세한 방법은 본서를 직접 참조하도록 하자.  

다음에서는 JDBC 기반의 jdbcAuthentication()을 대신할 다른 인증 방법을 사용할 것이다. 그 전에 또 다른 사용자 스토어인 LDAP(Lightweight Directory Access Protocol)를 알아보도록 하자.

## 4.2.3 LDAP 기반 사용자 스토어(p132~133)

LDAP 기반 인증으로 스프링 시큐리티를 구성하기 위해 ldapAuthentication() 메서드를 사용할 수 있다. 이 메서드는 LDAP를 jdbcAuthentication() 처럼 사용할 수 있게 해 준다. 다음 configure() 메서드에서는 LDAP 인증의 간단한 구성을 보여준다.

```java
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ldapAuthentication()
    .userSearchFilter("(uid={0})")
    .gorupSearchFilter("member={0}");
}
```

userSearchFilter()와 groupSearchFilter() 메서드는 LDAP 기본 쿼리의 필터를 제공하기 위해 사용된다. 여기에서는 사용자와 그룹을 검색하기 위해 사용하였다. 기본적으로 사용자와 그룹 모두의 LDAP 기본 쿼리는 비어 있어서 쿼리에 의한 검색이 LDAP 계층의 루트부터 수행된다는 것을 나타낸다. 그러나 다음과 같이 쿼리의 기준점을 지정하여 계층을 변경할 수 있다.

```java
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ladpAuthentication()
    	.userSearchBase("ou=people")
    	.userSearchFilter("(uid={0})")
    	.groupSearchBase("ou=groups")
    	.groupSearchFilter("member={0}");
}
```

userSearchBase() 메서드는 사용자를 찾기 위한 기준점 쿼리를 제공하고, groupSearchBase() 메서드는 그룹을 찾기 위한 기준점 쿼리를 제공한다. 따라서 위의 코드에서는 루트부터 검색하지 않는다. 즉, 사용자는 people 구성 단위(Organization Unit, OU)부터, 그룹은 groups 구성 단위부터 검색을 시작한다.

## 비밀번호 비교 구성하기(p133~134)

LDAP의 기본 인증 전략은 사용자가 직접 LDAP 서버에서 인증받도록 하는 것이다. 그러나 비밀번호를 비교하는 방법도 있다. 즉, 입력된 비밀번호를 LDAP 디렉터리에 전송한 후, 사용자의 비밀번호(userPassword) 속성 값과 비교하도록 LDAP 서버에 요청한다. 다음 코드는 비밀번호를 비교하여 LDAP 인증을 하는 경우를 보여준다. 여기에서는 비밀번호를 다른 속성(userPasscode)에 있다고 가정하고 passwordAttirbute() 메서드의 인자로 따로 설정하였다. 그리고 비밀번호를 암호화하기 위해 passwordEncoder() 역시 설정하였다.

```java
...
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ladpAuthentication()
    	.userSearchBase("ou=people")
    	.userSearchFilter("(uid={0})")
    	.groupSearchBase("ou=groups")
    	.groupSearchFilter("member={0}")
    	.passwordCompare()
    	.passwordEncoder(new BCryptPasswordEncoder())
    	.passwordAttribute("userPasscode");
}
```

여기에서는 bcrypt 암호화 해싱 인코더를 사용해서 비밀번호가 암호화된다. 이는 LDAP 서버에서도 bcrypt를 사용하여 비밀번호가 암호화된다는 것을 의미한다.

## 원격 LDAP 서버 참조하기(p134~135)

이제 LDAP 서버가 있는 위치에 대해 알아보자. 기본적으로 스프링 시큐리티의 LDAP 인증에서는 로컬 호스트의 33389 포트로 LDAP 서버가 접속된다고 간주한다. 만약 LDAP 서버가 다른 컴퓨터에서 실행 중이라면 contextSource() 메서드를 사용해서 해당 서버의 위치를 구성할 수 있다.

```java
@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ldapAuthentication()
    	.userSearchBase("ou=people")
    	.userSearchFilter("(uid={0})")
    	.groupSearchBase("ou=groups")
    	.groupSearchFilter("member={0}")
    	.passwordCompare()
    	.passwordEncoder(new BCryptPasswordEncoder())
    	.passwordAttribute("userPasscode")
  		.contextSource().url("ldap://tacocloud.com:389/dc=tacocloud,dc=com");                                                                                     }

```

contextSource() 메서드는 ContextSourceBuilder를 반환한다. 이것은 url() 메서드를 제공하므로 LDAP 서버의 위치를 지정할 수 있게 한다.

## 내장된 LDAP 서버 구성하기(p135~138)

인증을 기다리는 LDAP 서버가 없는 경우에는 스프링 시큐리티에서 제공하는 내장 LDAP 서버를 사용할 수 있다. 단 이 경우 빌드 명세에 의존성을 추가해야 한다.

```xml
...
	<dependency>
		<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-ldap</artifactId>
	</dependency>

	<dependency>
		<groupId>org.springframework.ldap</groupId>
    <artifactId>spring-ldap-core</artifactId>
	</dependency>

	<dependency>
		<groupId>org.springframework.security</groupId>
    <artifactId>spring-security-ldap</artifactId>
	</dependency>
</dependencies>
```

내장된 LDAP 서버를 사용할 때는 원격 LDAP 서버의 URL을 설정하는 대신 root() 메서드를 사용할 수 있다.

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ldapAuthentication()
    	.userSearchBase("ou=people")
    	.userSearchFilter("(uid={0})")
    	.groupSearchBase("ou=groups")
    	.groupSearchFilter("member={0}")
    	.passwordCompare()
    	.passwordEncoder(new BCryptPasswordEncoder())
    	.passwordAttribute("userPasscode")
  		.contextSource()
			.root("dc=tacocloud,dc=com");                                                                                      }
```

LDAP 서버가 시작될 때는 classpath에서 찾을 수 있는 LDIF(LDAP Data Interchange Format) 파일로부터 데이터를 로드한다. LDIF는 일반 텍스트 파일에 LDAP 데이터를 나타내는 표준화된 방법이다. 

만약 스프링이 classpath를 검색하지 않고 LDIF 파일을 찾도록 하려면, ldif() 메서드를 사용하여 LDIF 파일의 경로를 지정할 수 있다. 

```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.ldapAuthentication()
    	.userSearchBase("ou=people")
    	.userSearchFilter("(uid={0})")
    	.groupSearchBase("ou=groups")
    	.groupSearchFilter("member={0}")
      .contextSource()
			.root("dc=tacocloud,dc=com")
			.ldif("classpath:users.ldif")
  	  .and()
    	.passwordCompare()
    	.passwordEncoder(new BCryptPasswordEncoder())
    	.passwordAttribute("userPasscode")
}
```

여기에서는 classpath의 루트에서 users.ldif 파일을 찾아 LDAP 서버로 데이터를 로드하라고 요청한다. 내장된 LDAP 서버에 사용자 데이터를 로드하는 데 사용할 수 있는 LDIF 파일의 내용에 관하여는 본서를 참조하도록 하자.

지금까지는 스프링 시큐리티에 내장된 사용자 스토어(인메모리, JDBC 기반, LDAP 기반)를 살펴보았다. 하지만 타코 클라우드 애플리케이션에서는 기본적으로 제공하는 정보(사용자의 이름, 비밀번호, 사용 가능한지 사용자인지의 활성화 여부) 사용자 명세 정보가 필요하다. 다음부터는 사용자 인증을 커스터마이징하는 방법에 대해 알아보자.

## 사용자 도메인 객체와 퍼시스턴스 정의하기(p138~141)

애플리케이션을 사용하려는 타코 클라우드 고객이 사용자 등록을 할 때는 사용자 이름과 비밀번호 외에도 전체 이름, 주소, 전화번호까지 제공해야 한다. 주문 폼에 미리 보여주기 위해 사용하는 것이지만 다양한 목적으로도 사용할 수 있다. 먼저 사용자를 나타내는 User 클래스는 다음과 같다.

```java
package tacos;

import java.util.Arrays;
import java.util.Collection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGerantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import lombok.AccessLevel;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;

@Entity
@Data
@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)
@RequiredArgsConstructor
public class User implements UserDetails {
    private static final long serialVersionUID = 1L;
    
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    
    private final String username;
    private final String password;
    private final String fullname;
    private final String street;
    private final String city;
    private final String state;
    private final String zip;
    private final String phoneNumber;
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    
    
    @Override
    public boolean isCredentialNonExpired() {
        return true;
    }
    
    
    @Override
    public boolean isEnabled() {
        return true;
    }
}
```

User 클래스는 스프링 시큐리티의 UserDetails 인터페이스를 구현하며, 기본 사용자 정보를 프레임워크에 제공한다. 예를 들어 해당 사용자에게 부여된 권한과 해당 사용자 계정을 사용할 수 있는지의 여부 등이다.

일단 지금은 타코 클라우드에서 사용자를 비활성화할 필요가 없으므로 메서드 이름이 is로 시작하고 Expired로 끝나는 메서드들은 모두 true(사용자가 활성화됨을 나타냄)를 반환한다.

다음에는 리퍼지터리 인터페이스를 정의할 수 있다.

```java
package tacos.data
    
import org.springframework.data.repository.CrudRepository;
import tacos.User;

public interface UserRepository extends CrudRepository<User, Long> {
    User findByUsername(String username);
}
```

3장에서 배웠듯이, 스프링 데이터 JPA는 UserRepository 인터페이스의 구현체(클래스)를 런타임에 자동으로 생성한다. 따라서 이것을 사용하는 사용자 명제 서비스를 작성할 준비가 된 것이다.

## 사용자 명세 서비스 생성하기(p141~144)

스프링 시큐리티의 UserDetailService는 다음과 같이 간단한 인터페이스이다.

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String useranme) throws UsernameNotFoundException;
}
```

다음은 타코 클라우드 애플리케이션에서 사용할 사용자 명세 서비스 클래스이다.

```java
package tacos.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetials.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import tacos.User;
import tacos.data.UserRepository;

@Service
public class UserRepositoryUserDetailsService implements UserDetailsService {
    private UserRepository userRepo;
    
    @Autowired
    public UserRepositoryUserDetailsService(UserRepository userRepo) {
        this.userRepo = userRepo;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepo.findByUsername(username);
        if (user != null) {
            return user;
        }
        throw new UsernameNotFoundException(
        		"'User ' + username + "' not found");
    }
}
```

UserRepositoryUserDetailsService 클래스에는 @Service 애노테이션이 지정되어 있다. 이는 스프링의 스테레오타입 애노테이션 중 하나이고, 스프링이 컴포넌트 검색을 해준다는 것을 의미한다. 따라서 이 클래스를 따로 빈으로 선언하지 않아도 된다. 스프링이 자동으로 클래스를 찾아 빈으로 생성하기 때문이다.

그러나 커스텀 명세 서비스를 여전히 스프링 시큐리티에 구성해야 한다. 이전에 작성했던 SecurityConfig 클래스의 configure() 메서드를 다음과 같이 변경하자.

```java
...
import org.springframework.security.core.userdetails.UserDetailsService;
...
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    ...
	@Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .userDetailsService(userDetailsService);
    }
}
```

SecurityConfig로 자동 주입된 UserDetailsService 인스턴스를 인자로 전달하여 userDetailService() 메서드를 호출한다.

그리고 JDBC 기반 인증에서 했던 것과 같이 비밀번호가 암호화되어 데이터베이스에 저장될 수 있도록 비밀번호 인코더를 구성해야 한다.

```JAVA
...
import org.springframework.security.core.userdetials.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

import org.springframework.context.annotation.Bean;
...
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    ...
	@Autowired
	private UserDetailsService userDetailsService;
    
    @Bean
    public PasswordEncoder encoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .userDetailsService(userDetailsService)
        	.passwordEncoder(encoder());
    }
    ...
}
```

여기에서 configure() 메서드의 제일 마지막 코드를 살펴보자. 단순히 encoder() 메서드를 호출한 후 반환값을 passwordEncoder()의 인자로 전달하는 것처럼 보인다. 그러나 실제로는 다음 절차를 따른다. encoder()에 @Bean 애노테이션이 지정되었으므로, encoder() 메서드가 생성한 BCryptPasswordEncoder 인스턴스가 스프링 플리케이션 컨텍스트에 등록, 관리되며, 이 인스턴스가 애플리케이션 컨텍스트로부터 주입되어 반환된다. 이로써 우리가 원하는 PasswordEncoder 빈 객체를 스프링의 관리 하에 사용할 수 있다(이는 클래스와 클래스 인스턴스 생성 및 주입의 전 과정을 스프링이 관리하는 @Component 애노테이션과는 의미가 다르다).

이제 JPA 리퍼지터리에서 사용자 정보를 읽는 커스텀 사용자 명세 서비스를 갖게 되었으므로 데이터베이스에 사용자 정보를 저장하는 방법이 필요하다. 이를 위해 타코 클라우드의 사용자 등록 페이지를 생성하자.


## 사용자 등록하기(p144~148)

스프링 시큐리티는 사용자 등록 절차에 직접 개입하지 않기 때문에 이것을 처리하기 위한 스프링 MVC 코드를 작성할 것이다.다음의 RegistrationController 클래스에서는 등록 폼을 보여주고 처리한다.

```java
package tacos.security;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import tacos.data.UserRepository;

@Controller
@RequestMapping("/register")
public class RegistrationController {
    private UserRepository userRepo;
    private PasswordEncoder passwordEncoder;
    
    public RegistrationController(
    		UserRepository userRepo, PasswordEncoder passwordEncoder) {
        this.userRepo = userRepo;
        this.passwordEncoder = passwordEncoder;
    }
    
    @GetMapping
    public String registerForm() {
        return "registration";
    }
    
    @PostMapping
    public String processRegistration(RegistrationForm form) {
        userRepo.save(form.toUser(passwordEncoder));
        return "redirect:/login";
    }
    
}
```

이제 /register의 GET 요청이 registerForm() 메서드에 의해 처리된다. 이 메서드에서는 논리 뷰 이름인 registration만 반환한다. 다음에서는 registration 뷰를 정의하는 Thymeleaf 템플릿을 보여준다.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="EUC-KR">
    <title>Taco Cloud</title>
  </head>
  
  <body>
	<h1>Register</h1>
	<img th:src="@{/images/TacoCloud.png}" />
	<form method="POST" th:action="@{/register}" id="registerForm">
		<label for="username">Username: </label> 
		<input type="text" name="username" /><br /> 
		
		<label for="password">Password: </label> 
		<input type="password" name="password" /><br /> 
		
		<label for="confirm">Confirm password: </label> 
		<input type="password" name="confirm" /><br /> 
		
		<label for="fullname">Full name: </label> 
		<input type="text" name="fullname" /><br />
		
		<label for="street">Street: </label> 
		<input type="text" name="street" /><br />
		
		<label for="city">City: </label> 
		<input type="text" name="city" /><br />
		
		<label for="state">State: </label> 
		<input type="text" name="state" /><br />
		
		<label for="zip">Zip: </label> 
		<input type="text" name="zip" /><br />
		
		<label for="phone">Phone: </label> 
		<input type="text" name="phone" /><br />
		
		<input type="submit" value="Register" />
	</form>
  </body>
</html>
```

위의 등록 폼이 제출되면 processRegistration() 메서드에서 HTTP POST 요청이 처리된다. 이때 메서드의 인자로 전달된 RegistrationForm 객체가 요청 데이터와 바인딩된다. RegistrationForm 클래스는 다음과 같다.

```java
package tacos.security;

import org.springframework.security.crypto.password.PasswordEncoder;
import lombok.Data;
import tacos.User;

@Data
public class RegistrationForm {
    
    private String username;
    private String password;
    private String fullname;
    private String street;
    private String city;
    private String state;
    private String zip;
    private String phone;
    
    public User toUser(PasswordEncoder passwordEncoder) {
        return new User(
            username, passwordEncoder.encode(password),
            fullname, street, city, state, zip, phone);
    }
}
```

이제 타코 클라우드 애플리케이션의 사용자 등록과 인증 지원이 완성되었다. 그러나 지금 애플리케이션을 시작해도 등록 페이지를 볼 수 없다. 기본적으로 모든 웹 요청은 인증이 필요하기 때문이다. 이 문제를 해결하기 위해 다음에서는 웹 요청의 보안을 처리하는 방법을 살펴본다.

## 4.3 웹 요청 보안 처리하기(p148)

타코를 디자인하거나 주문하기 전에 사용자를 인증해야 한다는 것이 타코 클라우드 애플리케이션의 보안 요구사항이다. 하지만 홈페이지, 로그인 페이지, 등록 페이지는 인증되지 않은 모든 사용자가 사용할 수 있어야 한다.

이런 보안 규칙을 구성하려면 앞서 작성한 SecurityConfig 클래스에 다음의 configure(HttpSecurity) 메서드를 오버라이딩해야 한다.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    ...
}
```

이 configure() 메서드는 HttpSecurity 객체를 인자로 받는다. 이 객체는 웹 수준에서 보안을 처리하는 방법을 구성하는 데 사용된다. HttpSecurity를 사용해서 구성할 수 있는 것은 다음과 같다.

- HTTP 요청 처리를 허용하기 전에 충족되어야 할 **특정 보안 조건** 을 구성한다.
- **커스텀 로그인 페이지** 를 구성한다.
- 사용자가 애플리케이션의 **로그아웃** 을 할 수 있도록 한다.
- **CSRF 공격** 으로부터 보호하도록 구성한다.

해당 요청 시에 사용자가 합당한 권한을 갖는지 확인하는 것이 HttpSecurity 구성에서 가장 많이 하는 것 중 하나이다. 타코 클라우드 고객이 이런 보안 요구사항들을 충족하는지 확인하는 방법을 지금부터 알아보자.
