# Chapter 03. 데이터로 작업하기

이 장에서는 데이터 퍼시스턴스(persistence)(저장 및 지속성 유지)를 타코 클라우드 애플리케이션에 추가할 것이다. 먼저는 상용구 코드(boilerplate code)를 없애기 위해 스프링의 **JDBC 지원 기능 **을 사용하는 방법에 대해 배울 것이다. 그 다음 더 많은 코드를 줄일 수 있는  **JPA(Java Persistence API)** 로 데이터 리퍼지터리를 사용하는 방법을 알아볼 것이다.

## 3.1 JDBC를 사용해서 데이터 읽고 쓰기(p73~75)

관계형 데이터를 사용할 때 자바 개발자들이 가장 많이 사용하는 방법은 크게 두 가지가 있다. JDBC와 JPA가 그 방법이며, 스프링은 이 두 가지를 모두 지원한다. 이중 먼저 스프링이 JDBC를 지원하는 방법을 중점적으로 알아볼 것이다. 

스프링의 JDBC 지원은 JdbcTemplate 클래스에 기반을 둔다. JdbcTemplate은 JDBC를 사용할 때 요구되는 형식적이고 상투적인 코드없이 관계형 데이터베이스에 대한 SQL 연산을 수행할 수 있는 방법을 제공한다.

JdbcTemplate이 무슨 일을 하는지 이해하기 위해 두 가지 예시를 소개할 것이다. 먼저는 JdbcTemplate을 사용하지 않고 자바로 간단한 SQL 쿼리를 수행하는 방법을 살펴보자.

```JAVA
@Override
public Ingredient findById(String id) {
    Connection connection = null;
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    
    try {
        connection = dataSource.getConnection();
        statement = connection.prepareStatement(
        	"select id, name, type from Ingredient where id = ?");
        statement.setString(1, id);
        resultSet = statement.executeQuery();
        Ingredient ingredient = null;
        if (resultSet.next()) {
            ingredient = new Ingredient(
            	resultSet.getString("id"),
                resultSet.getString("name"),
                Ingredient.Type.valueOf(resultSet.getString("type")));
        }
        return ingredient;
    } catch (SQLException e) {
        // ~~
    } finally {
        if (resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException e) {}
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {}
        }
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {}
        }
    }
    return null;
}
```

위에는 데이터베이스 연결(connection) 생성, 명령문(statement) 생성, 그리고 연결과 명령문 및 결과 세트(result set)를 닫고 클린업하는 코드가 나와 있다. 여기에 SQLException을 위한 catch 문이나, 데이터베이스 연결 생성 실패 또는 작성 오류가 있는 쿼리 문제 등을 해결하기 위해서 따로 작업해야 하는 예외 처리까지 포함하여 꽤 많은 분량을 작업해야 한다는 것을 알 수 있다.

다음에는 이와 대조되는 JdbcTemplate 사용 메서드를 알아보자.

```java
private JdbcTemplate jdbc;

@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select id, name, type from Ingredient where id=?",
    	this::mapRowToIngredient, id);
}

private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
    	throw SQLException {
    return new Ingredient(
    	rs.getString("id"),
    	rs.getString("name"),
    	Ingredient.Type.valueOf(rs.getString("type"))); 
}
```

위의 코드에서는 명령문이나 데이터베이스 연결 객체를 생성하는 코드가 아예 없다. 그리고 메서드 실행이 끝나고 그런 객체들을 클린업하는 코드 또한 없다. 대신 쿼리를 수행하고(JdbcTemplate의 queryForObject() 메서드), 그 결과를 Ingredient 객체로 생성하는(mapRowToIngredient() 메서드) 것에 초점을 두는 코드만 존재한다.

이제부터는 타코 클라우드 애플리케이션의 데이터에 접근하고 이를 제어하는 데 초점을 맞출 것이다. 우선, 도메인 객체를 수정하는 것부터 시작하자.

## 3.1.1 퍼시스턴스를 고려한 도메인 객체 수정하기(p75~76)

일반적으로 객체를 데이터베이스에 저장할 때 해당 객체를 고유하게 식별하는 필드(id)를 추가하는 것이 좋다. 그리고 객체가 언제 생성되었는지 알면 유용하므로, 객체가 저장된 날짜와 시간을 갖는 필드 역시 추가하도록 하자.

아래에서는 Taco와 Order 객체에 id와 createAt(placedAt) 속성을 각각 추가하였다.

```java
...
import java.util.Date;

@Data
public class Taco {
    private Long id;
    private Date createdAt;
    ...
}
```

```java
...
import java.util.Date;

@Data
public class Order {
    private Long id;
    private Date placedAt;
    ...
}
```

참고로 여기에서 게터와 세터 및 생성자는 런타임에 Lombok이 자동으로 생성해준다.

이제 도메인 클래스들은 퍼시스턴스를 고려하여 코드 작성을 마쳤다. 다음에서는 JdbcTemplate을 사용하여 객체들을 데이터베이스에 읽고 쓰는 방법을 알아보자.

## 3.1.2 JdbcTemplate 사용하기(p76~78)

JdbcTemplate을 사용하기 위해 프로젝트 classpath에 추가해야 한다. 방법은 간단하게 스프링 부트의 JDBC 스타터 의존성을 빌드 명세에 추가하면 된다. 

또한, 데이터를 저장할 데이터베이스가 필요하다. 저자는 빌드 명세에 H2 내장 데이터베이스 의존성을 추가하였다. 향후에는 외부 데이터베이스를 사용하기 위해 애플리케이션을 구성하는 방법을 알아볼 것이다.

## JDBC 리퍼지터리 정의하기(p78~81)

식자재(Ingredient) 리퍼지터리는 다음 연산을 수행해야 한다.

- 데이터베이스의 모든 식자재 데이터를 쿼리하여 Ingredient 객체 List에 넣어야 한다.
- id를 사용하여 하나의 Ingredient를 쿼리해야 한다.
- Ingredient 객체를 데이터베이스에 저장해야 한다.

다음 IngredientRepository 인터페이스에서는 위의 세 가지 연산을 각각 메서드로 정의한다.

```java
public interface IngredientRepository {
    Iterable<Ingredient> findAll();
    Ingredient findById(String id);
    Ingredient save(Ingredient ingredient);
}
```

이제 IngredientRepository에 정의한 일들을 JdbcTemplate을 이용하여 데이터베이스 쿼리에 사용할 수 있도록 구현해야 한다. 구현 코드를 작성하는 첫 번째 단계로 아래와 같이 리퍼지터리 클래스를 생성하자.

```java
package tacos.data;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import tacos.Ingredient;

@Repository
public class JdbcIngredientRepositroy {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
}
```

JdbcIngredientRepository 클래스에는 @Repository 애노테이션이 지정되었다. 이는 @Controller와 @Component 외에 스프링이 정의하는 몇 안 되는 스테레오타입(stereotype) 애노테이션이다. 

> 스프링 MVC에서는 클래스의 역할을 구분하는 것이 중요하다. 스테레오타입 애노테이션은 스프링에서 주로 사용하는 **역할 그룹** 을 나타내는 애노테이션이다. 예를 들어, **@Component**는 스프링이 자동으로 탐색하여 생성하는 빈으로 특정 클래스를 지정하는 클래스 수준의 애노테이션이고, **@Repository**는 @Component에서 특화된 것으로 **데이터 액세스 관련** 애노테이션이다. **@Controller** 또한 @Component에서 특화된 애노테이션이며, 이것이 지정된 클래스가 **스프링 웹 MVC 컨트롤러** 라는 것을 알려준다.

즉,  JdbcIngredientRepostiroy 클래스에 @Repository를 지정하면, 스프링 컴포넌트 검색에서 이 클래스를 자동으로 찾아서 스프링 애플리케이션 컨텍스트의 빈으로 생성해준다.

그리고 JdbcIngredientRepostiroy 빈이 생성되면 @Autowired 애노테이션을 통해 스프링이 해당 빈을 JdbcTemplate에 주입(연결)한다. JdbcIngredientRepostiroy의 생성자에서는 JdbcTemplate 참조를 인스턴스 변수에 저장한다. 이 변수는 데이터베이스의 데이터를 쿼리하고 추가하기 위해 findAll()과 findById() 메서드에서 사용될 것이다.

```java
...
import java.sql.ResultSet;
import java.sql.SQLException;

@Repository
public class JdbcIngredientRepostiroy implements IngredientRepository {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
    
    @Override
    public Iterable<Ingredient> findAll() {
        return jdbc.query("select id, name, type from Ingredient",
                         this::mapRowToIngredient);
    }
    
    @Override
    public Ingredient findById(String id) {
        return jdbc.queryForObject(
        "select id, name, type from Ingredient where id=?",
        this::mapRowToIngredient, id);
    }
    
    private Ingredient mapRowToIngredient(ResultSet rs, int rowNum) 
        	throw SQLException {
       	return new Ingredient(
        	rs.getString("id"),
            rs.getString("name"),
            Ingredient.Type.valueOf(rs.getString("type")));
    }
}
```

객체가 저장된 컬렉션을 반환하는 findAll() 메서드는 JdbcTemplate의 query() 메서드를 사용한다. query() 메서드는 두 개의 인자를 받는다. 첫 번째 인자는 쿼리를 수행하는 SQL(select 명령)이며, 두 번째 인자는 스프링의 RowMapper 인터페이스를 구현한 mapRowToIngredient 메서드이다. query() 메서드에서는 쿼리로 생성된 결과 세트(ResultSet 객체)의 행(row) 개수만큼 호출되며, 결과 세트의 모든 행을 각각 객체(여기에서는 Ingredient)로 생성하고 List에 저장한 후 반환한다. 또한 query()에서는 해당 쿼리에서 요구하는 매개변수들의 내역을 마지막 인자로 받을 수 있지만 여기에서는 필요하지 않아 생략하였다.

findById() 메서드는 하나의 Ingredient 객체만 반환한다. 따라서 query() 대신 JdbcTemplate의 queryForObject() 메서드를 사용한다. 이 메서드는 query()와 동일하게 실행되지만, 하나의 객체만 반환한다는 것이 다르다. 이 메서드의 첫 번째와 두 번째 인자는 query()와 같으며, 세 번째 인자는 검색할 행의 id를 전달한다. 그러면 이 id가 첫 번째 인자로 전달된 SQL(select 명령)에 있는 물음표(?)에 들어가 쿼리에 사용된다.

앞서 mapRowToIngredient는 RowMapper 인터페이스를 구현한 메서드라고 하였다. 아래에서는 RowMapper의 mapRow()를 구현한 코드를 보여준다.

```java
@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select if, name, type from Ingredient where id=?",
    	new RowMapper<Ingredient>() {
            public Ingredient mapRow(ResultSet rs, int rowNum)
                	throws SQLException {
                return new Ingredient(
                rs.getString("id"),
                rs.getString("name"),
                Ingredient.Type,valueOf(rs.getString("type")));
            };
        }, id);
}
```

 데이터베이스의 데이터를 읽기 전에 데이터를 쓸 수(저장할 수) 있어야 하므로 다음부터는 IngredientRepository 인터페이스의 save() 메서드를 구현할 것이다.

## 데이터 추가하기(p82~84)

JdbcTemplate의 **update() 메서드** 는 데이터베이스에 **데이터를 추가** 또는 **변경** 하는 쿼리에 사용할 수 있다.

```java
...
@Override
public Ingredient save(Ingredient ingredient) {
    jdbc.update(
    "insert into Ingredient (id, name, typw) values (?, ?, ?)",
    ingredient.getId(),
    ingredient.getName(),
    ingredient.getType().toString());
  return ingredient;
}
```

update() 메서드에는 수행될 SQL 문자열과 쿼리 매개변수에 지정할 값이 인자로 전달된다. 여기에서는 3개의 매개변수를 가지며, save() 메서드의 인자로 전달되는 식자재 ingredient 객체의 id, name, type 속성 값이 각 매개변수에 지정된다.

이제 JdbcIngredientRepository가 완성되었기 때문에 DesignTacoController에 이를 주입(연결)하고, 이전에 하드코딩했던 Ingredient 객체 List 대신, 데이터베이스로부터 읽은 데이터로 생성한 List를 제공할 수 있게 되었다.

```java
package tacos.web;

import java.util.ArrayList;
...
import org.springframework.beans.factory.annotation.Autowired;

import tacos.data.IngredientRepository;
...
@Slf4j
@Controller
@RequestMappping("/design")
public class DesignTacoController {
    
    private final IngredientRepository ingredientRepo;
    
    @Autowired
    public DesignTacoController(IngredientRepository ingredientRepo) {
        this.ingredientRepo = ingredientRepo;
    }
    
    @GetMapping
    public String showDesignForm(Model model) {
        List<Ingredient> ingredients = new ArrayList<>();
        ingredientRepo.findAll().forEach(i -> ingredients.add(i));
        
        Type[] types = Ingredient.Type.values();
        for (Type type : types) {
            model.addAttribute(type.toString().toLowerCase(),
				filterByType(ingredients, type));
        }
        
        model.addAttribute("taco", new Taco());
        
        return "design";
    }
    ...
}
```

 이제 애플리케이션을 실행할 준비가 거의 다 되었다. 그러나 Ingredient 테이블에서 데이터를 얻기 위해서 먼저 이 테이블을 생성해야 하고, 식자재 데이터를 미리 추가해 놓아야 한다. 다음에서 이 작업을 진행할 것이다. 

## 3.1.3 스키마 정의하고 데이터 추가하기(p84~87)

Ingredient 테이블 외에도 주문 정보오 타코 디자인(각 타코의 식자재 구성) 정보를 저장할 테이블들이 필요하다. 다음 이미지는 우리가 필요한 테이블과 테이블 간의 관계를 보여준다. 

![image](https://user-images.githubusercontent.com/49539592/130308918-797eba89-a046-41d0-af08-8f7d369ed662.png)

각 테이블은 다음의 용도로 사용된다.

- **Ingredients**: 식자재 정보를 저장한다.
- **Taco**: 사용자가 식자재를 선택하여 생성한 타코 디자인에 관한 정보를 저장한다.
- **Taco_Ingredients**: Taco와 Ingredient 테이블 간의 관계를 나타내며, Taco 테이블의 각 행(row)에 대해 하나 이상의 행(타코를 식자재와 연관시키는)을 포함한다(하나의 타코에는 하나 이상의 식자재가 포함될 수 있다).
- **Taco_Order**: 주문 정보를 저장한다.
- **Taco_Order_Tacos**: Taco_Order와 Taco 테이블 간의 관계를 나타내며, Taco_Order 테이블의 각 행에 대해 하나 이상의 행(주문을 타코와 연관시키는)을 포함한다(한 건의 주문에는 하나 이상의 타코가 포함될 수 있다.)

다음은 위의 테이블들을 생성하는 SQL을 보여준다.

```sql
create table if not exists Ingredient (
    id varchar(4) not null,
    name varchar(25) not null,
    type varchar(10) not null
);

create table if not exists Taco (
    id identity,
    name varchar(50) not null,
    createdAt timestamp not null
);

create table if not exists Taco_Ingredients (
    taco bigint not null,
    ingredient varchar(4) not null
);

alter table Taco_Ingredients
    and foreign key (taco) references Taco(id);
alter table Taco_Ingredients
    and foreign key (ingredent) references Ingredient(id);

create table if not exists Taco_Order (
	id identity,
    deliveryName varchar(50) not null,
    deliveryStreet varchar(50) not null,
    deliveryCity varchar(50) not null,
    deliveryState varchar(2) not null,
    deliveryZip varchar(10) not null,
    ccNumber varchar(16) not null,
    ccExpiration varchar(5) not null,
    ccCVV varchar(3) not null,
    placedAt timestamp not null
);

create table if not exists Taco_Order_Tacos (
	tacoOrder bigint not null,
    taco bigint not null
);

alter table Taco_Order_Tacos
    and foreign key (tacoOrder) references Taco_Order(id);
alter table Taco_Order_Tacos
	and foreign key (taco) references Taco(id);
```

위의 스키마는 schema.sql 이라는 이름의 파일로 애플리케이션 classpath 루트 경로 안에 작성한다. 그러면 애플리케이션이 시작될 때 사용 중인 데이터베이스에서 schema.sql 파일의 SQL이 자동으로 실행된다. 여기 프로젝트에서는 위의 SQL을 schema.sql 이름의 파일로 src/main/resources 폴더에 저장하였다.

한편 우리는 식자재 데이터를 데이터베이스에 미리 저장해야 한다. 다행히 스프링 부트는 애플리케이션이 시작될 때 data.sql이라는 이름의 파일도 실행한다. (앞의 schema.sql처럼 이 파일도 src/main/resources 폴더에 저장한다). 따라서 다음과 같이 SQL insert 명령을 사용하여 식자재 데이터를 미리 데이터베이스에 추가할 수 있다.

```sql
delete from Taco_Order_Tacos;
delete from Taco_Ingredients;
delete from Taco;
delete from Taco_Order;

delete from Ingredient;
insert into Ingredient (id, name, type)
                values ('FLTO', 'Flour Tortilla', 'WRAP');
insert into Ingredient (id, name, type)
                values ('COTO', 'Corn Tortilla', 'WRAP');
insert into Ingredient (id, name, type)
                values ('GRBF', 'Ground Beef', 'PROTEIN');
insert into Ingredient (id, name, type)
                values ('CARN', 'Carnitas', 'PROTEIN');
insert into Ingredient (id, name, type)
                values ('TMTO', 'Diced Tomatoes', 'VEGGIES');
insert into Ingredient (id, name, type)
                values ('LETC', 'Lettuce', 'VEGGIES');
insert into Ingredient (id, name, type)
                values ('CHED', 'Cheddar', 'CHEESE');
insert into Ingredient (id, name, type)
                values ('JACK', 'Monterrey Jack', 'CHEESE');
insert into Ingredient (id, name, type)
                values ('SLSA', 'Salsa', 'SAUCE');
insert into Ingredient (id, name, type)
                values ('SRCR', 'Sour Cream', 'SAUCE');
```

 ## 3.1.4 타코와 주문 데이터 추가하기(p87)

지금까지 JdbcTemplate을 사용하여 데이터베이스에 데이터를 저장하는 방법을 전반적으로 알아보았다. JdbcIngredientRepository의 save() 메서드에서는 JdbcTemplate의 update() 메서드를 사용하여 Ingredient 객체를 데이터베이스 데이터로 저장한다.

더 나아가 데이터를 저장할 때  JdbcIngredientRepository에서 했던 것보다 더 많은 처리가 필요할 수 있다. JdbcTemplate을 사용하여 데이터를 저장하는 방법은 두 가지가 있다.

- 직접 update() 메서드를 사용한다.
- SimpleJdbcInsert 래퍼(wrapper) 클래스를 사용한다.

Ingredient 객체를 저장할 때보다 퍼시스턴스 처리가 더 복잡할 때 어덯게 update() 메서드를 사용하는지 알아보자.

## JdbcTemplate을 사용해서 데이터 저장하기(p87~94)

우선 타코와 주문 리퍼지터리에서 Taco와 Order 객체를 저장하기 위한 인터페이스를 정의하자.

```java
package tacos.data;

import tacos.Taco;

public interface TacoRepository {
    Taco save(Taco design);
}
```

```java
package tacos.data;

import tacos.Order;

public interface OrderRepository {
    Order save(Order order);
}
```

사용자가 식자재를 선택하여 생성한 타코 디자인을 저장하려면 해당 타코와 연관된 식자재 데이터도 Taco_Ingredients 테이블에 저장해야 한다. 어떤 식자재를 해당 타코에 넣었는지 알 수 있어야 하기 때문이다. 

마찬가지로 주문을 저장하려면 해당 주문과 연관된 타코 데이터를 Taco_Order_Tacos 테이블에 저장해야 한다. 해당 주문에 어떤 타코들이 연관된 것인지 알 수 있어야 하기 때문이다. 이런 이유로 단순히 식자재를 테이블에 저장하는 것보다 타코와 주문을 저장하는 것이 조금 더 복잡하다.

TacoRepository를 구현하려면 다음 일을 수행하는 save() 메서드를 구현해야 한다. 즉, 타코 디자인 정보(이름과 생성 시간)을 저장한 다음에, Taco 객체 id와 이 객체의 List에 저장된 각 Ingredient 객체 id를 Taco_Ingredients 테이블의 행으로 추가한다. 다음 코드에서는 이런 일의 수행을 구현한 JdbcTacoRepository 클래스를 보여준다.

```java
package tacos.data;

import java.sql.Timestamp;
import java.sql.Types;
import java.util.Arrays;
import java.util.Date;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementCreatorFactory;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import tacos.Ingredient;
import tacos.Taco;

@Repository
public class JdbcTacoRepository implements TacoRepository {
    
    private JdbcTemplate jdbc;
    
    public JdbcTacoRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
    
    @Override
    public Taco save(Taco taco) {
        long tacoId = saveTacoInfo(taco);
        taco.setId(tacoId);
        for (Ingredient ingredient : taco.getIngredients()) {
            saveIngredientToTaco(ingredient, tacoId);
        }
        return taco;
    }
    
    private long saveTacoInfo(Taco taco) {
        taco.setCreatedAt(new Date());
        PreparedStatementCreator psc =
            new PreparedStatementCreatorFactory(
        		"insert into Taco (name, createdAt) values (?, ?)",
            	Types.VARCHAR, Types.TIMESTAMP
        	).newPreparedStatementCreator(
        		Arrays.asList(
                	taco.getName(),
                	new Timestamp(taco.getCreatedAt().getTime())));
    	
        KeyHolder keyHolder = new GeneratedKeyHolder();
        jdbc.update(psc, keyHolder);
        
        return keyHolder.getKey().longValue();
    }
    
    private void saveIngredientToTaco(
    		Ingredient ingredient, long tacoId) {
        jdbc.update(
        	"insert into Taco_Ingredients (taco, ingredient) " +
        	"values (?, ?)",
        	tacoId, ingredient.getId());
    }
}
```

위의 코드로 알 수 있듯이, save() 메서드에서는 우선 Taco 테이블에 각 식자재를 저장하는 saveTacoInfo() 메서드를 호출한다. 그리고 이 메서드에서 반환된 타코 ID를 사용하여 타코와 식자재의 연관 정보를 저장하는 saveIngredientToTaco()를 호출한다.

Taco 테이블에 하나의 행을 추가할 때는 데이터베이스에서 생성되는 ID를 알아야 한다. 이를 위해 saveTacoInfo의 update() 메서드에서는 PrepatredStatementCreator 객체와 KeyHolder 객체를 인자로 받는다. 생성된 타코의 ID를 제공하는 것이 바로 이 KeyHolder이다. 이것을 사용하기 위해서는 PreparedStatementCreator도 함께 생성해야 한다. 

PreparedStatementCreator 객체를 생성하기 위해 먼저 PreparedStatementCreatorFactory 객체를 생성한다. 실행할 SQL 명령과 각 쿼리 매개변수의 타입을 각각 인자로 전달하여 해당 객체를 생성할 수 있다. 그리고 이 객체의 newPreparedStatementCreator()를 호출하고 PreparedStatementCreator 객체를 생성하기 위해 쿼리 매개변수의 값을 인자로 전달한다.

이렇게 하여 PreparedStatementCreator 객체가 생성되면 이 객체와 KeyHolder 객체를 인자로 전달하여 update() 메서드를 호출한다. 메서드의 호출이 끝나면 keyHolder.getKey().longValue() 호출을 통해 타코 ID를 반환 받을 수 있다.

이후 다시 리퍼지터리의 save() 메서드 블록으로 돌아와 saveIngredientToTaco() 메서드를 호출한다. 이를 통해 Taco 객체의 List의 저장된 각 Ingredient 객체를 반복 처리한다. saveIngredientToTaco() 메서드 내부의 update() 로 타코 ID와 Ingredient 객체 참조를 Taco_Ingredients 테이블에 저장한다.

사실 위의 코드는 아직 정상적으로 작동하지 않는다. 아래 코드에서 taco.getIngredients()의 반환 타입은 `List<String> ` 이나, 반복 처리는 Ingredient 타입으로 하고 있기 때문이다. 

```java
for (Ingredient ingredient : taco.getIngredients())
```

이를 정상적으로 사용하기 위해 Taco.java 파일을 다음의 코드처럼 변경하자.

```java
...
public class Taco {
    ...
	@Size(min=1, message="You must choose at least 1 ingredient")
    private List<Ingredient> ingredients;
}
```

이제 TacoRepository를 DesignTacoController에 주입하고 타코를 저장할 때 사용하기 위해 다음과 같이 코드를 수정하자.

```java
...
import tacos.data.TacoRepository;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.SessionAttributes;

...
import tacos.Order;
...
    
@Slf4j
@Controller
@RequestMapping("/design")
@SessionAttributes("order")
public class DesignTacoController {
    private final IngredientRepository ingredientRepo;
    private TacoRepository tacoRepo;
    
    @Autowired
    public DesignTacoController(
    		IngredientRepository ingredientRepo, TacoRepository tacoRepo) {
        this.ingredientRepo = ingredientRepo;
        this.tacoRepo = tacoRepo;
    }
    ...
        
	@ModelAttribute(name = "order")
    public Order order() {
        return new Order();
    }
    
    @ModelAttribute(name = "taco")
    public Taco taco() {
        return new Taco();
    }
    
    @PostMapping
    public String processDesign(
            @Valid Taco design,
            Errors erros, @ModelAttribute Order order) {
        
        if (errors.hasErrors()) {
            return "design";
        }
        
        Taco saved = tacoRepo.save(design);
        order.addDesign(saved);
        
        return "redirect:/orders/current";
    }
}
```

DesignTacoController에 @SessionAttributes("order")가 추가되고 order()와 taco()에 메서드 애노테이션 @ModelAttribute 애노테이션이 추가되었다. taco() 메서드와 동일하게 order()의 @ModelAttribute 애노테이션은 Order 객체가 모델에 생성되도록 해준다. 그러나 하나의 세션에서 생성되는 Taco 객체와 다르게(사용자가 타코를 생성할 때는 타코 디자인 폼에서 자신이 원하는 식자재를 선택하면 된다), 주문은 다수의 HTTP 요청에 걸쳐 존재해야 한다. 다수의 타코를 생성하고 그것들을 하나의 주문으로 추가할 수 있어야 하기 때문이다. 이때 클래스 수준의 @SesstionAttributes 애노테이션을 주문과 같은 모델 객체에 지정하면 된다. 그러면 세션에서 계속 보존되면서 다수의 요청에 걸쳐 사용될 수 있다.

하나의 타코 디자인을 실제로 처리(저장)하는 일은 processDesign() 메서드에서 수행된다. 이 매개변수의 값이 모델로부터 전달되어야 한다는 것과 스프링 MVC가 이 매개변수에 요청 매개변수를 바인딩하지 않아야 한다는 것을 나타내기 위해서이다.

전달된 데이터의 유효성 검사를 한 후 processDesign() 에서는 주입된 TacoRepository를 사용해서 타코를 저장한다. 그 다음에 세션에 보존된 Order에 Taco 객체를 추가한다.

위의 코드에서 order.addDesign(saved); 부분은 addDesign() 메서드를 구현하지 않았기 때문에 에러 표시가 날 것이다. 다음 Order 클래스에서 addDesign() 메서드와 생성한 타코들을 보관할 tacos 속성을 추가하자.

```java
...
import java.util.ArrayList;
import java.util.List;
...
@Data
publc class Order {
    ...
	@Digits(integer=3, fraction=0, message="Invalid CVV")
    private String ccCVV;
    
    private List<Taco> tacos = new ArrayList<>();
    
    public void addDesign(Taco design) {
        this.tacos.add(design);
    }
}
```

사용자가 주문 폼에 입력을 완료하고 제출할 때까지 Order 객체는 세션에 남아 있고 데이터베이스에 저장되지 않는다. 이제 주문을 저장하기 위해서는 OrderController가 OrderRepository를 사용할 수 있어야 한다. 다음에서 OrderRepository를 구현하는 클래스를 작성하도록 하자.

## SimpleJdbcInsert를 사용해서 데이터 추가하기(p94~102)

주문을 저장할 경우를 살펴보자. 주문 데이터를 Taco_Order 테이블에 저장하고, 해당 주문의 각 타코에 대한 id도 Taco_Order_Tacos 테이블에 저장해야 한다. 앞에서 타코를 저장할 때 살펴보았던 PreparedStatementCreator를 대신해 이번에는 SimpleJdbcInsert를 사용하는 방법을 사용할 것이다. SimpleJdbcInsert는 데이터를 더 쉽게 테이블에 추가하기 위해 JdbcTemplate을 래핑한 객체이다.

우선 OrderRepository를 구현하는 JdbcOrderRepository를 생성하자. JdbcOrderRepository 생성자에서는 Taco_Order와 Taco_Order_Tacos 테이블에 데이터를 추가하기 위해 두 개의 SimpleJdbcInsert 인스턴스를 생성한다.

```java
package tacos.data;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;
    
import com.fasterxml.jackson.databind.ObjectMapper;

import tacos.Taco;
import tacos.Order;

@Repository
public calss JdbcOrderRepository implements OrderRepository {
    private SimpleJdbcInsert orderInserter;
    private SimpleJdbcInsert orderTacoInserter;
    private ObjectMapper objectMapper;
    
    @Autowired
    public JdbcOrderRepository(JdbcTemplate jdbc) {
        this.orderInserter = new SimpleJdbcInsert(jdbc)
            	.withTableName("Taco_Order")
            	.usingGeneratedKeyColumns("id");
        
        this.orderTacoInserter = new SimpleJdbcInsert(jdbc)
            	.withTableName("Taco_Order_Tacos");
        
        this.objectMapper = new ObjectMapper();
    }
}
```

JdbcOrderRepository 생성자에서는 JdbcTemplate을 사용하여 두 개의 SimpleJdbcInsert 인스턴스를 생성한다.

orderInserter 인스턴스 변수에 지정되는 첫 번째 SimpleJdbcInsert 인스턴스는 Taco_Order 테이블에 주문 데이터를 추가하기 위해 구성되고 이때 Order 객체의 id 속성 값은 데이터베이스가 생성해 주는 것을 사용한다. 

orderTacoInserter 인스턴스 변수에 지정되는 두 번째 SimpleJdbcInsert 인스턴스는 Taco_Order_Tacos 테이블에 해당 주문 id와 이것과 연관된 타코들의 id를 추가하기 위해 구성된다. 그러나 어떤 id 값들을 Taco_Order_Tacos 테이블의 데이터에 생성할 것인지는 지정하지 않는다.(데이터베이스에서 생성해주는 것을 사용하지 않고 이미 생성된 주문 id와 이것과 연관된 타코들의 id를 우리가 지정할 것이기 때문이다).

또한 JdbcOrderRepository 생성자에서는 Jackson ObjectMapper 인스턴스를 생성하여 인스턴스 변수에 저장한다. 잭슨은 원래 JSON을 처리하기 위한 것이지만, 여기에서는 주문과 이와 연관된 타코들을 저장할 때 어떻게 용도를 변경해서 사용하는지 추후 살펴볼 것이다.

이제는 save() 메서드에서 SimpleJdbcInsert 인스턴스를 어떻게 사용하는지 다음 코드와 함께 살펴보자.

```java
package tacos.data;

import java.util.Date;
...
    ...
    @Override
    public Order save(Order order) {
    	order.setPlacedAt(new Date());
    	long orderId = saveOrderDetails(order);
    	order.setId(orderId);
    	List<Taco> tacos = order.getTacos();
    
    	for (Taco taco : tacos) {
            saveTacoToOrder(taco, orderId);
        }
    	
    	return order;
	}
	
	private long saveOrderDetails(Order order) {
        @SuppressWarnings("unchecked")
        Map<String,Object> values = 
            objectMapper.convertValue(order, Map.class);
        values.put("placedAt", order.getPlacedAt());
        
        long orderId =
            	orderInserter
            		.executeAndReturnKey(values)
            		.longValue();
        
        return orderId;
    }

	private void saveTacoToOrder(Taco taco, long orderId) {
        Map<String, Obejct> values = new HashMap<>();
        
        values.put("tacoOrder", orderId);
        values.put("taco", taco.orderId);
        
        orderTacoInserter.execute(values);
    }

```

save() 메서드에서는 직접적으로 저장하는 일을 하지 않고 Order와 이와 연관된 Taco 객체들을 저장하는 처리(메서드 호출)를 총괄한다. 따라서 실제로 저장하는 일은 saveOrderDetails()와 saveTacoToOrder() 메서드에 위임한다.

SimpleJdbcInsert는 데이터를 추가하는 메서드로 execute()와 executeAndReturnKey()를 갖는다. 두 메서드 모두 Map<String, Object>를 인자로 받는다. 이때 Map의 키는 데이터가 추가되는 테이블의 열(column) 이름과 대응되고, Map의 값은 해당 열에 추가되는 값과 대응된다.

Order 객체는 여러 개의 속성을 가지며 속성 모두가 테이블의 열과 같은 이름을 갖는다. 따라서 saveOrderDetails() 메서드에서 잭슨 ObjectMapper의 convertValue() 메서드를 사용하여 Order를 Map으로 변환하였다. Map을 생성한 이후 values에서 키가 placedAt 항목의 값을 Order 객체의 placedAt 속성의 값으로 변경한다. 왜냐하면 ObjectMapper는 Date 타입의 값을 long 타입의 값으로 변환하여 Taco_Order 테이블의 placedAt 열 타입과 호환되지 않기 때문이다.

 Order 데이터의 모든 속성 값을 가지는 Map이 준비되었으므로 orderInserter의 executeAndReturnKey() 메서드를 호출할 수 있다. 이 메서드를 호출하면 주문 데이터가 Taco_Order 테이블에 저장된 후 데이터베이스에서 생성된 ID가 Number 객체로 반환된다. 이 객체의 longValue()를 호출하여 long 타입의 orderId 값을 반환할 수 있다.

saveTacoToOrder() 메서드는 객체를 Map으로 변환하기 위해 ObjectMapper를 사용하는 대신, 직접 Map을 생성하고 각 항목에 적합한 값을 설정한다. 여기서 Map의 키는 위에서와 마찬가지로 테이블의 열 이름과 같다.

이제 OrderRepository를 OrderController에 주입하여 사용하면 된다. 다음은 OrderController의 전체 코드이다.

```java
package tacos.web;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.support.SessionStatus;

import lombok.extern.slf4j.Slf4j;
import tacos.Order;
import tacos.data.OrderRepository;
import javax.validation.Valid;
import org.springframework.validation.Errors;

@Slf4j
@Controller
@RequestMapping("/orders")
@SessionAttributes("order")
public class OrderController {
    
    private OrderRepository orderRepo;
    
    public OrderController(OrderRepository orderRepo) {
		this.orderRepo = orderRepo;
	}
    
    @GetMapping("/current")
    public String orderForm() {
        return "orderForm";
    }
    
    @PostMapping
    public String processOrder(@Valid Order order,
                              Errors errors, SessionStatus sessionStatus) {
        if (errors.hasErrors()) {
            return "orderForm";
        }
        
        orderRepo.save(order);
        sessionStatus.setComplete();
        
        return "redirect:/"
    }
}
```

주문 객체가 데이터베이스에 저장된 후에는 더 이상 이를 세션에 보존할 필요가 없다. 만약 주문 객체를 제거하지 않으면 이전 주문과 이와 연관된 타코가 세션에 계속 남아 있게 되고, 다음 주문은 이전 주문에 포함되었던 타코 객체들을 가지고 시작할 것이다. 따라서 processOrder() 메서드에서 setComplete() 메서드를 호출하여 세션을 재설정한다.

이제, 데이터의 타입을 변환해 주는 컨버터(converter) 클래스를 작성하자. 이 클래스는 스프링의 Converter 인터페이스에 정의된 convert() 메서드를 구현한다. 따라서 우리가 Converter에 지정한 타이 변환이 필요할 때 convert() 메서드가 자동 호출된다. 우리 애플리케이션에서는 String 타입의 식자재 ID를 사용하여 데이터베이스에 저장된 특정 식자재 데이터를 읽은 후 이를 Ingredient 객체로 변환하기 위해 컨버터를 사용한다(그리고 컨버터로 변환된 Ingredient 객체는 다른 곳에서 List에 저장된다).

```java
package tacos.web;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;

import tacos.Ingredient;
import tacos.data.IngredientRepository;

@Component
public class IngredientByIdConverter
    	implements Converter<String, Ingredient> {
    private IngredientRepository ingredientRepo;
    
    @Autowired
    public IngredientByConverter(IngredientRepository ingredientRepo) {
        this.ingredientRepo = ingredientRepo;
    }
    
    @Override
    public Ingredient convert(String id) {
        return ingredientRepo.findById(id);
    }
}
```

 IngredientByIdConverter 클래스에 @Component 애노테이션을 지정했으므로 이 클래스는 스프링에 의해 자동 생성/ 주입되는 빈으로 생성된다. 그리고 생성자에 @Autowired 애노테이션을 지정했으므로 IngredientRepository 인터페이스를 구현한 빈(IngredientRepository) 인스턴스가 생성자의 인자로 주입된다.

Converter<String, Ingredient> 에서 String은 변환할 값의 타입이고, Ingredient는 변환된 값의 타입이다. 

여기까지 했다면 이제 타코 클라우드 애플리케이션을 시작하고 http://localhost:8080/design에 접속하여 원하는 대로 얼마든지 타코와 주문을 생성할 수 있다. 

애플리케이션과 더불어 데이터베이스도 직접 살펴볼 수 있다. 여기에서는 H2를 사용하고 스프링 부트 DevTools가 이미 포함되어 있으므로, 웹 브라우저에서 http://localhost:8080/h2-console에 접속하여 H2 콘솔을 볼 수 있다.

처음에는 로그인 대화상자가 나타난다. JDBC URL 필드에  jdbc:h2:emem:testdb를 입력하고 사용자명에 sa를 입력한 후, 연결을 클릭한다. 로그인이 되면 타코 클라우드의 모든 테이블에서 어떤 쿼리든지 수행할 수 있다.

지금까지 스프링의 JdbcTemplate과 SimpleJdbcInsert를 사용하여 일반적인 JDBC보다 훨씬 더 쉽게 관계형 데이터베이스를 사용하였다. 하지만 스프링 데이터 JPA(Java Persistence API)를 사용하면 더욱 쉽게 데이터베이스를 사용할 수 있다. 다음부터는 스프링 데이터 JPA를 사용하여 데이터 퍼시스턴스를 더 쉽게 처리하는 방법에 대해 알아볼 것이다.

## 3.2 스프링 데이터 JPA를 사용해서 데이터 저장하고 사용하기(p103)

스프링 데이터 프로젝트는 여러 개의 하위 프로젝트로 구성된 다소 규모 있는 프로젝트이다. 대부분의 하위 프로젝트는 다양한 데이터베이스 유형을 사용한 데이터 퍼시스턴스에 초점을 두고 있다. 가장 많이 알려진 스프링 데이터 프로젝트들은 다음과 같다.

- **스프링 데이터 JPA**: 관계형 데이터베이스의 JPA 퍼시스턴스
- **스프링 데이터 MongoDB**: 몽고 문서형 데이터베이스의 퍼시스턴스
- **스프링 데이터 Neo4**: Neo4j 그래프 데이터베이스의 퍼시스턴스
- **스프링 데이터 레디스(Redis)**: 레디스 키-값 스토어의 퍼시스턴스
- **스프링 데이터 카산드라(Cassandra)**: 카산드라 데이터베이스의 퍼시스턴스

스프링 데이터에서는 **리퍼지터리 인터페이스를 기반으로** 이 인터페이스를 구현체를 자동으로 생성해준다.

스프링 데이터가 작동하는 방법을 알기 위해 앞에서 작성한 JDBC 기반의 리퍼지터리를 스프링 데이터 JPA로 교체하는 것부터 시작할 것이다. 가장 먼저는 스프링 데이터 JPA를 프로젝트 빌드 파일에 추가하자.

## 3.2.1 스프링 데이터 JPA를 프로젝트에 추가하기(p103~104)

스프링 데이터 JPA는 JPA 스타터를 통해 스프링 부트 애플리케이션에서 사용할 수 있다. 이 스타터 의존성에는 스프링 데이터 JPA는 물론이고 **JPA를 구현한 Hibernate까지도 포함** 한다. 본서에서는 아래 pom.xml 파일의 빌드 명세에 의존성을 추가하였다.

```xml
...
<dependencies>
	...
      <dependencies>
      	<groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
      </dependencies>
</dependencies>
```

만약 다른 JPA 구현 라이브러리를 사용하고 싶다면 Hibernate 의존성을 제외하고 새로 선택한 JPA 라이브러리를 포함해야 한다. 자세한 내용은 자신이 선택한 JPA 구현 라이브러리 문서를 참고하자. 지금부터 우리는 애플리케이션의 도메인 객체를 다시 보면서 JPA 퍼시스턴스에 필요한 애노테이션을 추가할 것이다. 

## 3.2.2 도메인 객체에 애노테이션 추가하기(p104~108)

스프링 데이터는 리퍼지터리를 생성할 때 놀라운 일을 수행하지만 이를 위해서 JPA 매핑(mapping) 애노테이션을 도메인 객체에 추가해야 한다. 다음 코드에서는 Ingredient, Taco, Order 클래스에 애노테이션을 각각 추가해주었다.

```java
package tacos;

import javax.persistence.Entity;
import javax.persistence.Id;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.Data;
import lombok.RequiredArgsConsturctor;

@Data
@RequiredArgsConstructor
@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)
@Entity
public class Ingredient {
    
    @Id
    private final String id;
    private final String name;
    private final Type type;
    
    public static enum Type {
        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
    }
}
```

Ingredient 클래스를 JPA 개체(entity)로 선언하려면 반드시 **@Entity 애노테이션** 을 추가해야 한다. 그리고 이것의 id 속성에는 **반드시 @Id 를 지정** 하여 이 속성이 데이터베이스의 개체를 고유하게 식별한다는 것을 나타내야 한다.

또한 JPA에서는 개체가 **인자 없는 생성자** 를 가져야 한다. 이를 위해 Lombok의 **@NoArgsConstructor** 를 지정하였다. 하지만 인자 없는 생성자의 사용을 **원치 않을 경우**, access 속성을 **AccessLevel.PRIVATE** 으로 설정하여 클래스 외부에서 사용하지 못하게 할 수 있다. 

그리고 초기화가 필요한 final 속성이 들어 있으므로 force 속성을 true로 설정하였다. 이에 따라 Lombok이 자동 생성한 생성자에서 그 속성들을 null로 설정할 수 있다.

@Data는 인자가 있는 생성자를 자동으로 추가한다. 그러나 @NoArgsConstructor가 지정되면 그런 생성자는 제거된다. 하지만 위에서처럼 @RequiredArgsConstructor를 추가하면 private의 인자 없는 생성자와 더불어 인자가 있는 생성자를 여전히 가질 수 있다. 다음의 Taco 클래스도 JPA 개체로 사용하기 위해 애노테이션을 추가하자.

```java
package tacos;

import java.util.Date;
import java.util.List;

import javax.persistence.Entity
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.PrePersist;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import lombok.Data;

@Data
@Entity
public class Taco {
    
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    
    private Date createdAt;
    
    @NotNull
    @Size(min=5, message="Name must be at least 5 characters long")
    private String name;
    
    @ManyToMany(targetEntity=Ingredient.class)
    @Size(min=1, message="You must choose at least 1 ingredient")
    private List<Ingredient> ingredients;
    
    @Prepersist
    void createdAt() {
        this.createdAt = new Date();
    }
}
```

Ingredient와 동일하게 Taco 클래스에도 @Entity를 지정하였고 id 속성에는 @Id를 지정하였다. id 속성에는 데이터베이스가 자동으로 생성해 주는 ID 값이 사용된다. 따라서 strategy 속성 값이 GeneratedType.AUTO로 설정된 @GeneratedValue 애노테이션이 지정되었다.

Taco와 이와 연관된 Ingredient들의 관계를 선언하기 위해 ingredients 속성에 @ManyToMany 애노테이션이 지정되었다. 하나의 Taco 객체가 많은 Ingredient 객체를 가질 수 있고, 반대로 하나의 Ingredient가 여러 Taco 객체에 포함될 수 있기 때문이다.

또한, createdAt() 메서드에는 **@PrePersist** 애노테이션을 지정하였다. 이 메서드는 Taco 객체가 저장되기 전에 createdAt 속성을 현재 일자와 시간으로 설정하는 데 사용된다. 마지막으로 Order 클래스를 JPA 개체로 사용하기 위해 애노테이션을 추가하자.

```java
package tacos;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.PrePersist;
import javax.persistence.Table;
import javax.validation.constraints.Digits;
import javax.validation.constraints.Pattern;
import org.hibernate.validator.constraints.CreditCardNumber;
import javax.validation.constraints.NotBlank;
import lombok.Data;

@Data
@Entity
@Table(name="Taco_Order")
public class Order implements Serializable {
    
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    
    private Date placedAt;
    
    ...
        
	@ManyToMany(targetEntity=Taco.class)
    private List<Taco> tacos = new ArrayList<>();
    
    public void addDesign(Taco design) {
        this.tacos.add(design);
    }
    
    @PrePersist
    void placedAt() {
        this.placedAt = new Date();
    }
}
```

클래스 수준의 @Table 애노테이션은 Order 개체가 데이터베이스의 Taco_Order 테이블에 저장되어야 함을 의미한다. 만약 이 애노테이션을 지정하지 않으면 JPA가 Order라는 이름의 테이블로 Order 개체를 저장할 것이다(참고로 Order는 SQL의 예약어이므로 사용하지 않는다). 

도메인 객체의 JPA 애노테이션이 추가되었으므로 이제 리퍼지토리를 이에 맞게 변경할 것이다.

## 3.2.3 JPA 리퍼지터리 선언하기(p108~112)

JDBC 버전의 리퍼지터리에서는 리퍼지터리가 제공하는 메서드를 명시적으로 선언하였다. 하지만 스프링 데이터에서는 이를 대신해 CrudRepository 인터페이스를 확장(extends)할 수 있다. 

```java
package tacos.data;

import org.springframework.data.repository.CrudRepository;

import tacos.Ingredient;

public interface IngredientRepository extends CrudRepository<Ingredient, String> {
}
```

**CrudRepository 인터페이스** 에는 데이터베이스의 CRUD(Create(생성), Read(읽기), Update(변경), Delete(삭제)) 연산을 위한 메서드가 다양하게 선언되어 있다.

CrudRepository의 첫 번째 매개변수는 **리퍼지터리에 저장되는 개체 타입** 이고, 두 번째 매개변수는 **개체 ID 속성의 타입** 이다. IngredientRepository의 경우 매개변수 타입이 Ingredient와 String 이어야 한다.

이와 유사하게 TacoRepository와 OrderRepository 인터페이스도 다음과 같이 정의할 수 있다.

```java
package tacos.data;

import org.springframework.data.repository.CrudRepository;

import tacos.Taco;

public interface TacoRepository extends CrudRepository<Taco, Long> {
}
```

```java
package tacos.data;

import org.springframework.data.repository.CrudRepository;

import tacos.Order;

public interface OrderRepository extends CrudRepository<Order, Long> {
}
```

스프링 데이터 JPA의 장점 중 하나는 애플리케이션이 시작될 때 각 인터페이스 **구현체(클래스 등)를 자동으로 생성** 해 준다 는 것이다. 더 이상 사용하지 않는 인터페이스 구현체들인 JdbcIngredientRepository, JdbcTacoRepository, JdbcOrderRepository 는 삭제해주자.

다음으로 부트스트랩 클래스를 변경하자.

```java
package tacos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;

import tacos.Ingredient.Type;
import tacos.data.IngredientRepository;

@SpringBootApplication
public class TacoCloudApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(TacoCloudApplication.class, args);
    }
    
    @Bean
    public CommandLineRunner dataLoader(IngredinetRepository repo) {
        return new CommandLineRunner() {
            @Override
            public void run(String... args) throws Exception {
                repo.save(new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
				repo.save(new Ingredient("COTO", "Corn Tortilla", Type.WRAP));
				repo.save(new Ingredient("GRBF", "Ground Beef", Type.PROTEIN));
				repo.save(new Ingredient("CARN", "Carnitas", Type.PROTEIN));
				repo.save(new Ingredient("TMTO", "Diced Tomatoes", Type.VEGGIES));
				repo.save(new Ingredient("LETC", "Lettuce", Type.VEGGIES));
				repo.save(new Ingredient("CHED", "Cheddar", Type.CHEESE));
				repo.save(new Ingredient("JACK", "Monterrey Jack", Type.CHEESE));
				repo.save(new Ingredient("SLSA", "Salsa", Type.SAUCE));
				repo.save(new Ingredient("SRCR", "Sour Cream", Type.SAUCE));
            }
        };
    }
}
```

여기서 부트스트랩 클래스를 변경한 이유는 애플리케이션이 시작되면서 호출되는 dataLoader() 메서드에서 식자재 데이터를 데이터베이스에 미리 저장할 필요가 있기 때문이다(JDBC 기반에서는 애플리케이션이 시작될 때 자동 실행되는 data.sql에서 이 작업을 해주었다).

다음으로 IngredientByIdConverter 코드를 변경하자.

```java
...
import java.util.Optional;
...
@Component
public class IngredientByIdConverter implements Converter<String, Ingredient> {
    ...
	
	@Override
	public Ingredient convert(String id) {
        Optional<Ingredient> optionalIngredient = ingredientRepo.findById(id);
        return optionalIngredient.isPresent() ?
            				optionalIngredient.get() : null;
    }
}
```

컨버터를 변경하는 이유는 우리 애플리케이션에서 필요해서 그런 것이지 스프링 데이터 JPA를 사용하기 위해 꼭 해야 하는 것은 아니다.

이제 스프링 데이터 JPA를 사용한 애플리케이션을 실행할 수 있다. 애플리케이션을 시작하고 http://localhost:8080/design에 접속하여 JDBC 기반일 때와 동일하게 작동하는지 확인하자.

다음에서는 더 복잡한 요구사항을 처리하기 위해 리퍼지터리를 커스터마이즈하는 방법을 알아볼 것이다.

## 3.2.4 JPA 리퍼지터리 커스터마이징하기(p112~115)

CrudRepository에서 제공하는 기본적인 CRUD 연산에 더하여, 특정 ZIP(우편번호) 코드로 배달된 모든 주문 데이터도 데이터베이스로부터 가져와야 한다고 하자. 이 경우는 다음의 메서드를 선언하면 쉽게 해결할 수 있다.

```JAVA
List<Order> findByDeliveryZip(String deliveryZip);
```

 리퍼지터리 구현체를 생성할 때 스프링 데이터는 해당 리퍼지터리 인터페이스에 정의된 메서드를 찾아 메서드 이름을 분석하며, 저장되는 객체(여기에서는 Order)의 컨텍스트에서 메서드의 용도가 무엇인지 파악한다. 보닞ㄹ적으로 스프링 데이터는 일종의 DSL(Domain Specific Language)을 정의하여 퍼시스턴스에 관한 내용이 리퍼지터리 메서드의 시그니처에 표현된다.

스프링 데이터는 findByDeliveryZip() 메서드가 주문 객체(Order)들을 찾으려고 한다는 것을 안다. 왜냐하면 OrderRepository에서 CrudRepository의 매개변수를 Order라고 지정했기 때문이다. 그리고 메서드 이름인 findByDeliveryZip()은 이 메서드가 Order의 deliveryZip 속성과 일치하는 모든 개체를 찾아야 한다는 것을 확실하게 판단하도록 한다.

리퍼지터리 메서드 이름은 **동사, 생략 가능한 처리 대상, By, 그리고 서술어** 로 구성된다. findByDeliveryZip()의 경우, 동사가 find이고, 서술어가 DeliveryZip이며, 처리 대상은 명시적으로 지정되지 않았지만 묵시적으로 Order이다.

다음으로 더 복잡한 예가 있다. 지정된 일자 범위 내에서 특정 ZIP 코드로 배달된 모든 주문을 처리해야 한다고 가정하자. 이 경우 다음 메서드를 OrderRepository에 추가하면 된다.

```java
List<Order> readOrdersByDeliverZipAndPlacedAtBetween(
		String deliveryZip, Date startDate, Date endDate);
```

read에 위치하는 동사를 대신해 find나 get을 사용해도 좋다. 모두 하나 이상의 개체를 읽는 일을 수행한다. By 뒤에 있는 DeliveryZip은 개체의 속성으로 있는 .deliveryZip 또는 .delivery.zip 속성 값의 일치 여부를 확인한다. 마찬가지로 PlacedAt도 .placedAt 또는 .placed.at 속성 값의 일치 여부를 확인한다. 마지막으로 메서드의 처리 대상(Orders)이 생략되어도 여기서는 Orders가 된다. 따라서 메서드 이름이 readPuppiesBy... 일 경우에도 Order 개체를 찾는다. CrudRepository 인터페이스의 매개변수 타입으로 Order를 지정했기 때문이다.

deliveryZip에는 묵시적으로 Equals 연산이 수행되고, placedAt에는 Between 연산이 수행된다.  스프링 데이터 메서드 시그니처에서 사용할 수 있는 **연산자** 들을 정리하면 다음과 같다.

- **IsAfter, After, IsGreaterThan, GreaterThan**
- **IsGreaterThanEqual, GreaterThanEqual**
- **IsBefore, Before, IsLessThan, LessThan**
- **IsLessThanEqual, LessThanEqual**
- **IsBetween, Between**
- **IsNull, Null**
- **IsNotNull, NotNull**
- **IsIn, In**
- **IsNotIn, NotIn**
- **IsStartingWith, StartingWith, StartsWith**
- **IsEndingWith, EndingWith, EndsWith**
- **IsContaining, Containing, Contains**
- **IsLike, Like**
- **IsNotLike, NotLike**
- **IsTrue, True**
- **IsFalse, False**
- **Is, Equals**
- **IsNot, Not**
- **IgnoringCase, IgnoresCase**
- **AllIgnoreingCase, AllIgnoresCase** -> 모든 String 비교에서 대소문자를 무시할 때 사용

일부 사용 예시는 다음과 같다.

```java
List<Order> findByDeliveryToAndDeliveryCityAllIgnoresCase(
		String deliveryTo, String deliveryCity);
```

마지막으로 지정된 열의 값을 기준으로 결과를 정렬하기 위해 메서드 이름 끝에 OrderBy를 추가할 수 있다. 다음은 deliveryTo 속성 값을 기준으로 정렬하는 예이다.

```java
List<Order> findByDeliveryCityOrderByDeliveryTo(String city);
```

보다 복잡한 쿼리의 경우에는 메서드 이름 (연산자)만으로 감당하기 어렵다. 이때는 원하는 메서드 이름을 지정한 후 해당 메서드가 호출될 때 쿼리가 수행되도록 **@Query 애노테이션** 을 지정하자.

```java
@Query("Order o where o.deliveryCity='Seattle'")
List<Order> readOrdersDeliveredInSeattle();
```
