# Chapter 03. 데이터로 작업하기

이 장에서는 데이터 퍼시스턴스(persistence)(저장 및 지속성 유지)를 타코 클라우드 애플리케이션에 추가할 것이다. 먼저는 상용구 코드(boilerplate code)를 없애기 위해 스프링의 **JDBC 지원 기능 **을 사용하는 방법에 대해 배울 것이다. 그 다음 더 많은 코드를 줄일 수 있는  **JPA(Java Persistence API)** 로 데이터 리퍼지터리를 사용하는 방법을 알아볼 것이다.

## 3.1 JDBC를 사용해서 데이터 읽고 쓰기(p73~75)

관계형 데이터를 사용할 때 자바 개발자들이 가장 많이 사용하는 방법은 크게 두 가지가 있다. JDBC와 JPA가 그 방법이며, 스프링은 이 두 가지를 모두 지원한다. 이중 먼저 스프링이 JDBC를 지원하는 방법을 중점적으로 알아볼 것이다. 

스프링의 JDBC 지원은 JdbcTemplate 클래스에 기반을 둔다. JdbcTemplate은 JDBC를 사용할 때 요구되는 형식적이고 상투적인 코드없이 관계형 데이터베이스에 대한 SQL 연산을 수행할 수 있는 방법을 제공한다.

JdbcTemplate이 무슨 일을 하는지 이해하기 위해 두 가지 예시를 소개할 것이다. 먼저는 JdbcTemplate을 사용하지 않고 자바로 간단한 SQL 쿼리를 수행하는 방법을 살펴보자.

```JAVA
@Override
public Ingredient findById(String id) {
    Connection connection = null;
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    
    try {
        connection = dataSource.getConnection();
        statement = connection.prepareStatement(
        	"select id, name, type from Ingredient where id = ?");
        statement.setString(1, id);
        resultSet = statement.executeQuery();
        Ingredient ingredient = null;
        if (resultSet.next()) {
            ingredient = new Ingredient(
            	resultSet.getString("id"),
                resultSet.getString("name"),
                Ingredient.Type.valueOf(resultSet.getString("type")));
        }
        return ingredient;
    } catch (SQLException e) {
        // ~~
    } finally {
        if (resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException e) {}
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {}
        }
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {}
        }
    }
    return null;
}
```

위에는 데이터베이스 연결(connection) 생성, 명령문(statement) 생성, 그리고 연결과 명령문 및 결과 세트(result set)를 닫고 클린업하는 코드가 나와 있다. 여기에 SQLException을 위한 catch 문이나, 데이터베이스 연결 생성 실패 또는 작성 오류가 있는 쿼리 문제 등을 해결하기 위해서 따로 작업해야 하는 예외 처리까지 포함하여 꽤 많은 분량을 작업해야 한다는 것을 알 수 있다.

다음에는 이와 대조되는 JdbcTemplate 사용 메서드를 알아보자.

```java
private JdbcTemplate jdbc;

@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select id, name, type from Ingredient where id=?",
    	this::mapRowToIngredient, id);
}

private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
    	throw SQLException {
    return new Ingredient(
    	rs.getString("id"),
    	rs.getString("name"),
    	Ingredient.Type.valueOf(rs.getString("type"))); 
}
```

위의 코드에서는 명령문이나 데이터베이스 연결 객체를 생성하는 코드가 아예 없다. 그리고 메서드 실행이 끝나고 그런 객체들을 클린업하는 코드 또한 없다. 대신 쿼리를 수행하고(JdbcTemplate의 queryForObject() 메서드), 그 결과를 Ingredient 객체로 생성하는(mapRowToIngredient() 메서드) 것에 초점을 두는 코드만 존재한다.

이제부터는 타코 클라우드 애플리케이션의 데이터에 접근하고 이를 제어하는 데 초점을 맞출 것이다. 우선, 도메인 객체를 수정하는 것부터 시작하자.

## 3.1.1 퍼시스턴스를 고려한 도메인 객체 수정하기(p75~76)

일반적으로 객체를 데이터베이스에 저장할 때 해당 객체를 고유하게 식별하는 필드(id)를 추가하는 것이 좋다. 그리고 객체가 언제 생성되었는지 알면 유용하므로, 객체가 저장된 날짜와 시간을 갖는 필드 역시 추가하도록 하자.

아래에서는 Taco와 Order 객체에 id와 createAt(placedAt) 속성을 각각 추가하였다.

```java
...
import java.util.Date;

@Data
public class Taco {
    private Long id;
    private Date createdAt;
    ...
}
```

```java
...
import java.util.Date;

@Data
public class Order {
    private Long id;
    private Date placedAt;
    ...
}
```

참고로 여기에서 게터와 세터 및 생성자는 런타임에 Lombok이 자동으로 생성해준다.

이제 도메인 클래스들은 퍼시스턴스를 고려하여 코드 작성을 마쳤다. 이제 JdbcTemplate을 사용하여 이 객체들을 데이터베이스에 읽고 쓰는 방법을 알아보자.
