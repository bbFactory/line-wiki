# Chapter 03. 데이터로 작업하기

이 장에서는 데이터 퍼시스턴스(persistence)(저장 및 지속성 유지)를 타코 클라우드 애플리케이션에 추가할 것이다. 먼저는 상용구 코드(boilerplate code)를 없애기 위해 스프링의 **JDBC 지원 기능 **을 사용하는 방법에 대해 배울 것이다. 그 다음 더 많은 코드를 줄일 수 있는  **JPA(Java Persistence API)** 로 데이터 리퍼지터리를 사용하는 방법을 알아볼 것이다.

## 3.1 JDBC를 사용해서 데이터 읽고 쓰기(p73~75)

관계형 데이터를 사용할 때 자바 개발자들이 가장 많이 사용하는 방법은 크게 두 가지가 있다. JDBC와 JPA가 그 방법이며, 스프링은 이 두 가지를 모두 지원한다. 이중 먼저 스프링이 JDBC를 지원하는 방법을 중점적으로 알아볼 것이다. 

스프링의 JDBC 지원은 JdbcTemplate 클래스에 기반을 둔다. JdbcTemplate은 JDBC를 사용할 때 요구되는 형식적이고 상투적인 코드없이 관계형 데이터베이스에 대한 SQL 연산을 수행할 수 있는 방법을 제공한다.

JdbcTemplate이 무슨 일을 하는지 이해하기 위해 두 가지 예시를 소개할 것이다. 먼저는 JdbcTemplate을 사용하지 않고 자바로 간단한 SQL 쿼리를 수행하는 방법을 살펴보자.

```JAVA
@Override
public Ingredient findById(String id) {
    Connection connection = null;
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    
    try {
        connection = dataSource.getConnection();
        statement = connection.prepareStatement(
        	"select id, name, type from Ingredient where id = ?");
        statement.setString(1, id);
        resultSet = statement.executeQuery();
        Ingredient ingredient = null;
        if (resultSet.next()) {
            ingredient = new Ingredient(
            	resultSet.getString("id"),
                resultSet.getString("name"),
                Ingredient.Type.valueOf(resultSet.getString("type")));
        }
        return ingredient;
    } catch (SQLException e) {
        // ~~
    } finally {
        if (resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException e) {}
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {}
        }
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {}
        }
    }
    return null;
}
```

위에는 데이터베이스 연결(connection) 생성, 명령문(statement) 생성, 그리고 연결과 명령문 및 결과 세트(result set)를 닫고 클린업하는 코드가 나와 있다. 여기에 SQLException을 위한 catch 문이나, 데이터베이스 연결 생성 실패 또는 작성 오류가 있는 쿼리 문제 등을 해결하기 위해서 따로 작업해야 하는 예외 처리까지 포함하여 꽤 많은 분량을 작업해야 한다는 것을 알 수 있다.

다음에는 이와 대조되는 JdbcTemplate 사용 메서드를 알아보자.

```java
private JdbcTemplate jdbc;

@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select id, name, type from Ingredient where id=?",
    	this::mapRowToIngredient, id);
}

private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
    	throw SQLException {
    return new Ingredient(
    	rs.getString("id"),
    	rs.getString("name"),
    	Ingredient.Type.valueOf(rs.getString("type"))); 
}
```

위의 코드에서는 명령문이나 데이터베이스 연결 객체를 생성하는 코드가 아예 없다. 그리고 메서드 실행이 끝나고 그런 객체들을 클린업하는 코드 또한 없다. 대신 쿼리를 수행하고(JdbcTemplate의 queryForObject() 메서드), 그 결과를 Ingredient 객체로 생성하는(mapRowToIngredient() 메서드) 것에 초점을 두는 코드만 존재한다.

이제부터는 타코 클라우드 애플리케이션의 데이터에 접근하고 이를 제어하는 데 초점을 맞출 것이다. 우선, 도메인 객체를 수정하는 것부터 시작하자.

## 3.1.1 퍼시스턴스를 고려한 도메인 객체 수정하기(p75~76)

일반적으로 객체를 데이터베이스에 저장할 때 해당 객체를 고유하게 식별하는 필드(id)를 추가하는 것이 좋다. 그리고 객체가 언제 생성되었는지 알면 유용하므로, 객체가 저장된 날짜와 시간을 갖는 필드 역시 추가하도록 하자.

아래에서는 Taco와 Order 객체에 id와 createAt(placedAt) 속성을 각각 추가하였다.

```java
...
import java.util.Date;

@Data
public class Taco {
    private Long id;
    private Date createdAt;
    ...
}
```

```java
...
import java.util.Date;

@Data
public class Order {
    private Long id;
    private Date placedAt;
    ...
}
```

참고로 여기에서 게터와 세터 및 생성자는 런타임에 Lombok이 자동으로 생성해준다.

이제 도메인 클래스들은 퍼시스턴스를 고려하여 코드 작성을 마쳤다. 다음에서는 JdbcTemplate을 사용하여 객체들을 데이터베이스에 읽고 쓰는 방법을 알아보자.

## 3.1.2 JdbcTemplate 사용하기(p76~78)

JdbcTemplate을 사용하기 위해 프로젝트 classpath에 추가해야 한다. 방법은 간단하게 스프링 부트의 JDBC 스타터 의존성을 빌드 명세에 추가하면 된다. 

또한, 데이터를 저장할 데이터베이스가 필요하다. 저자는 빌드 명세에 H2 내장 데이터베이스 의존성을 추가하였다. 향후에는 외부 데이터베이스를 사용하기 위해 애플리케이션을 구성하는 방법을 알아볼 것이다.

## JDBC 리퍼지터리 정의하기(p78~81)

식자재(Ingredient) 리퍼지터리는 다음 연산을 수행해야 한다.

- 데이터베이스의 모든 식자재 데이터를 쿼리하여 Ingredient 객체 List에 넣어야 한다.
- id를 사용하여 하나의 Ingredient를 쿼리해야 한다.
- Ingredient 객체를 데이터베이스에 저장해야 한다.

다음 IngredientRepository 인터페이스에서는 위의 세 가지 연산을 각각 메서드로 정의한다.

```java
public interface IngredientRepository {
    Iterable<Ingredient> findAll();
    Ingredient findById(String id);
    Ingredient save(Ingredient ingredient);
}
```

이제 IngredientRepository에 정의한 일들을 JdbcTemplate을 이용하여 데이터베이스 쿼리에 사용할 수 있도록 구현해야 한다. 구현 코드를 작성하는 첫 번째 단계로 아래와 같이 리퍼지터리 클래스를 생성하자.

```java
package tacos.data;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import tacos.Ingredient;

@Repository
public class JdbcIngredientRepositroy {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
}
```

JdbcIngredientRepository 클래스에는 @Repository 애노테이션이 지정되었다. 이는 @Controller와 @Component 외에 스프링이 정의하는 몇 안 되는 스테레오타입(stereotype) 애노테이션이다. 

> 스프링 MVC에서는 클래스의 역할을 구분하는 것이 중요하다. 스테레오타입 애노테이션은 스프링에서 주로 사용하는 **역할 그룹** 을 나타내는 애노테이션이다. 예를 들어, **@Component**는 스프링이 자동으로 탐색하여 생성하는 빈으로 특정 클래스를 지정하는 클래스 수준의 애노테이션이고, **@Repository**는 @Component에서 특화된 것으로 **데이터 액세스 관련** 애노테이션이다. **@Controller** 또한 @Component에서 특화된 애노테이션이며, 이것이 지정된 클래스가 **스프링 웹 MVC 컨트롤러** 라는 것을 알려준다.

즉,  JdbcIngredientRepostiroy 클래스에 @Repository를 지정하면, 스프링 컴포넌트 검색에서 이 클래스를 자동으로 찾아서 스프링 애플리케이션 컨텍스트의 빈으로 생성해준다.

그리고 JdbcIngredientRepostiroy 빈이 생성되면 @Autowired 애노테이션을 통해 스프링이 해당 빈을 JdbcTemplate에 주입(연결)한다. JdbcIngredientRepostiroy의 생성자에서는 JdbcTemplate 참조를 인스턴스 변수에 저장한다. 이 변수는 데이터베이스의 데이터를 쿼리하고 추가하기 위해 findAll()과 findById() 메서드에서 사용될 것이다.

```java
...
import java.sql.ResultSet;
import java.sql.SQLException;

@Repository
public class JdbcIngredientRepostiroy implements IngredientRepository {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
    
    @Override
    public Iterable<Ingredient> findAll() {
        return jdbc.query("select id, name, type from Ingredient",
                         this::mapRowToIngredient);
    }
    
    @Override
    public Ingredient findById(String id) {
        return jdbc.queryForObject(
        "select id, name, type from Ingredient where id=?",
        this::mapRowToIngredient, id);
    }
    
    private Ingredient mapRowToIngredient(ResultSet rs, int rowNum) 
        	throw SQLException {
       	return new Ingredient(
        	rs.getString("id"),
            rs.getString("name"),
            Ingredient.Type.valueOf(rs.getString("type")));
    }
}
```

객체가 저장된 컬렉션을 반환하는 findAll() 메서드는 JdbcTemplate의 query() 메서드를 사용한다. query() 메서드는 두 개의 인자를 받는다. 첫 번째 인자는 쿼리를 수행하는 SQL(select 명령)이며, 두 번째 인자는 스프링의 RowMapper 인터페이스를 구현한 mapRowToIngredient 메서드이다. query() 메서드에서는 쿼리로 생성된 결과 세트(ResultSet 객체)의 행(row) 개수만큼 호출되며, 결과 세트의 모든 행을 각각 객체(여기에서는 Ingredient)로 생성하고 List에 저장한 후 반환한다. 또한 query()에서는 해당 쿼리에서 요구하는 매개변수들의 내역을 마지막 인자로 받을 수 있지만 여기에서는 필요하지 않아 생략하였다.

findById() 메서드는 하나의 Ingredient 객체만 반환한다. 따라서 query() 대신 JdbcTemplate의 queryForObject() 메서드를 사용한다. 이 메서드는 query()와 동일하게 실행되지만, 하나의 객체만 반환한다는 것이 다르다. 이 메서드의 첫 번째와 두 번째 인자는 query()와 같으며, 세 번째 인자는 검색할 행의 id를 전달한다. 그러면 이 id가 첫 번째 인자로 전달된 SQL(select 명령)에 있는 물음표(?)에 들어가 쿼리에 사용된다.

앞서 mapRowToIngredient는 RowMapper 인터페이스를 구현한 메서드라고 하였다. 아래에서는 RowMapper의 mapRow()를 구현한 코드를 보여준다.

```java
@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select if, name, type from Ingredient where id=?",
    	new RowMapper<Ingredient>() {
            public Ingredient mapRow(ResultSet rs, int rowNum)
                	throws SQLException {
                return new Ingredient(
                rs.getString("id"),
                rs.getString("name"),
                Ingredient.Type,valueOf(rs.getString("type")));
            };
        }, id);
}
```

 데이터베이스의 데이터를 읽기 전에 데이터를 쓸 수(저장할 수) 있어야 하므로 다음부터는 IngredientRepository 인터페이스의 save() 메서드를 구현할 것이다.
