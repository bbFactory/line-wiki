# Chapter 03. 데이터로 작업하기

이 장에서는 데이터 퍼시스턴스(persistence)(저장 및 지속성 유지)를 타코 클라우드 애플리케이션에 추가할 것이다. 먼저는 상용구 코드(boilerplate code)를 없애기 위해 스프링의 **JDBC 지원 기능 **을 사용하는 방법에 대해 배울 것이다. 그 다음 더 많은 코드를 줄일 수 있는  **JPA(Java Persistence API)** 로 데이터 리퍼지터리를 사용하는 방법을 알아볼 것이다.

## 3.1 JDBC를 사용해서 데이터 읽고 쓰기(p73~75)

관계형 데이터를 사용할 때 자바 개발자들이 가장 많이 사용하는 방법은 크게 두 가지가 있다. JDBC와 JPA가 그 방법이며, 스프링은 이 두 가지를 모두 지원한다. 이중 먼저 스프링이 JDBC를 지원하는 방법을 중점적으로 알아볼 것이다. 

스프링의 JDBC 지원은 JdbcTemplate 클래스에 기반을 둔다. JdbcTemplate은 JDBC를 사용할 때 요구되는 형식적이고 상투적인 코드없이 관계형 데이터베이스에 대한 SQL 연산을 수행할 수 있는 방법을 제공한다.

JdbcTemplate이 무슨 일을 하는지 이해하기 위해 두 가지 예시를 소개할 것이다. 먼저는 JdbcTemplate을 사용하지 않고 자바로 간단한 SQL 쿼리를 수행하는 방법을 살펴보자.

```JAVA
@Override
public Ingredient findById(String id) {
    Connection connection = null;
    PreparedStatement statement = null;
    ResultSet resultSet = null;
    
    try {
        connection = dataSource.getConnection();
        statement = connection.prepareStatement(
        	"select id, name, type from Ingredient where id = ?");
        statement.setString(1, id);
        resultSet = statement.executeQuery();
        Ingredient ingredient = null;
        if (resultSet.next()) {
            ingredient = new Ingredient(
            	resultSet.getString("id"),
                resultSet.getString("name"),
                Ingredient.Type.valueOf(resultSet.getString("type")));
        }
        return ingredient;
    } catch (SQLException e) {
        // ~~
    } finally {
        if (resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException e) {}
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {}
        }
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {}
        }
    }
    return null;
}
```

위에는 데이터베이스 연결(connection) 생성, 명령문(statement) 생성, 그리고 연결과 명령문 및 결과 세트(result set)를 닫고 클린업하는 코드가 나와 있다. 여기에 SQLException을 위한 catch 문이나, 데이터베이스 연결 생성 실패 또는 작성 오류가 있는 쿼리 문제 등을 해결하기 위해서 따로 작업해야 하는 예외 처리까지 포함하여 꽤 많은 분량을 작업해야 한다는 것을 알 수 있다.

다음에는 이와 대조되는 JdbcTemplate 사용 메서드를 알아보자.

```java
private JdbcTemplate jdbc;

@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select id, name, type from Ingredient where id=?",
    	this::mapRowToIngredient, id);
}

private Ingredient mapRowToIngredient(ResultSet rs, int rowNum)
    	throw SQLException {
    return new Ingredient(
    	rs.getString("id"),
    	rs.getString("name"),
    	Ingredient.Type.valueOf(rs.getString("type"))); 
}
```

위의 코드에서는 명령문이나 데이터베이스 연결 객체를 생성하는 코드가 아예 없다. 그리고 메서드 실행이 끝나고 그런 객체들을 클린업하는 코드 또한 없다. 대신 쿼리를 수행하고(JdbcTemplate의 queryForObject() 메서드), 그 결과를 Ingredient 객체로 생성하는(mapRowToIngredient() 메서드) 것에 초점을 두는 코드만 존재한다.

이제부터는 타코 클라우드 애플리케이션의 데이터에 접근하고 이를 제어하는 데 초점을 맞출 것이다. 우선, 도메인 객체를 수정하는 것부터 시작하자.

## 3.1.1 퍼시스턴스를 고려한 도메인 객체 수정하기(p75~76)

일반적으로 객체를 데이터베이스에 저장할 때 해당 객체를 고유하게 식별하는 필드(id)를 추가하는 것이 좋다. 그리고 객체가 언제 생성되었는지 알면 유용하므로, 객체가 저장된 날짜와 시간을 갖는 필드 역시 추가하도록 하자.

아래에서는 Taco와 Order 객체에 id와 createAt(placedAt) 속성을 각각 추가하였다.

```java
...
import java.util.Date;

@Data
public class Taco {
    private Long id;
    private Date createdAt;
    ...
}
```

```java
...
import java.util.Date;

@Data
public class Order {
    private Long id;
    private Date placedAt;
    ...
}
```

참고로 여기에서 게터와 세터 및 생성자는 런타임에 Lombok이 자동으로 생성해준다.

이제 도메인 클래스들은 퍼시스턴스를 고려하여 코드 작성을 마쳤다. 다음에서는 JdbcTemplate을 사용하여 객체들을 데이터베이스에 읽고 쓰는 방법을 알아보자.

## 3.1.2 JdbcTemplate 사용하기(p76~78)

JdbcTemplate을 사용하기 위해 프로젝트 classpath에 추가해야 한다. 방법은 간단하게 스프링 부트의 JDBC 스타터 의존성을 빌드 명세에 추가하면 된다. 

또한, 데이터를 저장할 데이터베이스가 필요하다. 저자는 빌드 명세에 H2 내장 데이터베이스 의존성을 추가하였다. 향후에는 외부 데이터베이스를 사용하기 위해 애플리케이션을 구성하는 방법을 알아볼 것이다.

## JDBC 리퍼지터리 정의하기(p78~81)

식자재(Ingredient) 리퍼지터리는 다음 연산을 수행해야 한다.

- 데이터베이스의 모든 식자재 데이터를 쿼리하여 Ingredient 객체 List에 넣어야 한다.
- id를 사용하여 하나의 Ingredient를 쿼리해야 한다.
- Ingredient 객체를 데이터베이스에 저장해야 한다.

다음 IngredientRepository 인터페이스에서는 위의 세 가지 연산을 각각 메서드로 정의한다.

```java
public interface IngredientRepository {
    Iterable<Ingredient> findAll();
    Ingredient findById(String id);
    Ingredient save(Ingredient ingredient);
}
```

이제 IngredientRepository에 정의한 일들을 JdbcTemplate을 이용하여 데이터베이스 쿼리에 사용할 수 있도록 구현해야 한다. 구현 코드를 작성하는 첫 번째 단계로 아래와 같이 리퍼지터리 클래스를 생성하자.

```java
package tacos.data;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import tacos.Ingredient;

@Repository
public class JdbcIngredientRepositroy {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
}
```

JdbcIngredientRepository 클래스에는 @Repository 애노테이션이 지정되었다. 이는 @Controller와 @Component 외에 스프링이 정의하는 몇 안 되는 스테레오타입(stereotype) 애노테이션이다. 

> 스프링 MVC에서는 클래스의 역할을 구분하는 것이 중요하다. 스테레오타입 애노테이션은 스프링에서 주로 사용하는 **역할 그룹** 을 나타내는 애노테이션이다. 예를 들어, **@Component**는 스프링이 자동으로 탐색하여 생성하는 빈으로 특정 클래스를 지정하는 클래스 수준의 애노테이션이고, **@Repository**는 @Component에서 특화된 것으로 **데이터 액세스 관련** 애노테이션이다. **@Controller** 또한 @Component에서 특화된 애노테이션이며, 이것이 지정된 클래스가 **스프링 웹 MVC 컨트롤러** 라는 것을 알려준다.

즉,  JdbcIngredientRepostiroy 클래스에 @Repository를 지정하면, 스프링 컴포넌트 검색에서 이 클래스를 자동으로 찾아서 스프링 애플리케이션 컨텍스트의 빈으로 생성해준다.

그리고 JdbcIngredientRepostiroy 빈이 생성되면 @Autowired 애노테이션을 통해 스프링이 해당 빈을 JdbcTemplate에 주입(연결)한다. JdbcIngredientRepostiroy의 생성자에서는 JdbcTemplate 참조를 인스턴스 변수에 저장한다. 이 변수는 데이터베이스의 데이터를 쿼리하고 추가하기 위해 findAll()과 findById() 메서드에서 사용될 것이다.

```java
...
import java.sql.ResultSet;
import java.sql.SQLException;

@Repository
public class JdbcIngredientRepostiroy implements IngredientRepository {
    
    private JdbcTemplate jdbc;
    
    @Autowired
    public JdbcIngredientRepository(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }
    
    @Override
    public Iterable<Ingredient> findAll() {
        return jdbc.query("select id, name, type from Ingredient",
                         this::mapRowToIngredient);
    }
    
    @Override
    public Ingredient findById(String id) {
        return jdbc.queryForObject(
        "select id, name, type from Ingredient where id=?",
        this::mapRowToIngredient, id);
    }
    
    private Ingredient mapRowToIngredient(ResultSet rs, int rowNum) 
        	throw SQLException {
       	return new Ingredient(
        	rs.getString("id"),
            rs.getString("name"),
            Ingredient.Type.valueOf(rs.getString("type")));
    }
}
```

객체가 저장된 컬렉션을 반환하는 findAll() 메서드는 JdbcTemplate의 query() 메서드를 사용한다. query() 메서드는 두 개의 인자를 받는다. 첫 번째 인자는 쿼리를 수행하는 SQL(select 명령)이며, 두 번째 인자는 스프링의 RowMapper 인터페이스를 구현한 mapRowToIngredient 메서드이다. query() 메서드에서는 쿼리로 생성된 결과 세트(ResultSet 객체)의 행(row) 개수만큼 호출되며, 결과 세트의 모든 행을 각각 객체(여기에서는 Ingredient)로 생성하고 List에 저장한 후 반환한다. 또한 query()에서는 해당 쿼리에서 요구하는 매개변수들의 내역을 마지막 인자로 받을 수 있지만 여기에서는 필요하지 않아 생략하였다.

findById() 메서드는 하나의 Ingredient 객체만 반환한다. 따라서 query() 대신 JdbcTemplate의 queryForObject() 메서드를 사용한다. 이 메서드는 query()와 동일하게 실행되지만, 하나의 객체만 반환한다는 것이 다르다. 이 메서드의 첫 번째와 두 번째 인자는 query()와 같으며, 세 번째 인자는 검색할 행의 id를 전달한다. 그러면 이 id가 첫 번째 인자로 전달된 SQL(select 명령)에 있는 물음표(?)에 들어가 쿼리에 사용된다.

앞서 mapRowToIngredient는 RowMapper 인터페이스를 구현한 메서드라고 하였다. 아래에서는 RowMapper의 mapRow()를 구현한 코드를 보여준다.

```java
@Override
public Ingredient findById(String id) {
    return jdbc.queryForObject(
    	"select if, name, type from Ingredient where id=?",
    	new RowMapper<Ingredient>() {
            public Ingredient mapRow(ResultSet rs, int rowNum)
                	throws SQLException {
                return new Ingredient(
                rs.getString("id"),
                rs.getString("name"),
                Ingredient.Type,valueOf(rs.getString("type")));
            };
        }, id);
}
```

 데이터베이스의 데이터를 읽기 전에 데이터를 쓸 수(저장할 수) 있어야 하므로 다음부터는 IngredientRepository 인터페이스의 save() 메서드를 구현할 것이다.

## 데이터 추가하기(p82~84)

JdbcTemplate의 **update() 메서드** 는 데이터베이스에 **데이터를 추가** 또는 **변경** 하는 쿼리에 사용할 수 있다.

```java
...
@Override
public Ingredient save(Ingredient ingredient) {
    jdbc.update(
    "insert into Ingredient (id, name, typw) values (?, ?, ?)",
    ingredient.getId(),
    ingredient.getName(),
    ingredient.getType().toString());
  return ingredient;
}
```

update() 메서드에는 수행될 SQL 문자열과 쿼리 매개변수에 지정할 값이 인자로 전달된다. 여기에서는 3개의 매개변수를 가지며, save() 메서드의 인자로 전달되는 식자재 ingredient 객체의 id, name, type 속성 값이 각 매개변수에 지정된다.

이제 JdbcIngredientRepository가 완성되었기 때문에 DesignTacoController에 이를 주입(연결)하고, 이전에 하드코딩했던 Ingredient 객체 List 대신, 데이터베이스로부터 읽은 데이터로 생성한 List를 제공할 수 있게 되었다.

```java
package tacos.web;

import java.util.ArrayList;
...
import org.springframework.beans.factory.annotation.Autowired;

import tacos.data.IngredientRepository;
...
@Slf4j
@Controller
@RequestMappping("/design")
public class DesignTacoController {
    
    private final IngredientRepository ingredientRepo;
    
    @Autowired
    public DesignTacoController(IngredientRepository ingredientRepo) {
        this.ingredientRepo = ingredientRepo;
    }
    
    @GetMapping
    public String showDesignForm(Model model) {
        List<Ingredient> ingredients = new ArrayList<>();
        ingredientRepo.findAll().forEach(i -> ingredients.add(i));
        
        Type[] types = Ingredient.Type.values();
        for (Type type : types) {
            model.addAttribute(type.toString().toLowerCase(),
				filterByType(ingredients, type));
        }
        
        model.addAttribute("taco", new Taco());
        
        return "design";
    }
    ...
}
```

 이제 애플리케이션을 실행할 준비가 거의 다 되었다. 그러나 Ingredient 테이블에서 데이터를 얻기 위해서 먼저 이 테이블을 생성해야 하고, 식자재 데이터를 미리 추가해 놓아야 한다. 다음에서 이 작업을 진행할 것이다. 

## 3.1.3 스키마 정의하고 데이터 추가하기(p84~87)

Ingredient 테이블 외에도 주문 정보오 타코 디자인(각 타코의 식자재 구성) 정보를 저장할 테이블들이 필요하다. 다음 이미지는 우리가 필요한 테이블과 테이블 간의 관계를 보여준다. 

![image](https://user-images.githubusercontent.com/49539592/130308918-797eba89-a046-41d0-af08-8f7d369ed662.png)

각 테이블은 다음의 용도로 사용된다.

- **Ingredients**: 식자재 정보를 저장한다.
- **Taco**: 사용자가 식자재를 선택하여 생성한 타코 디자인에 관한 정보를 저장한다.
- **Taco_Ingredients**: Taco와 Ingredient 테이블 간의 관계를 나타내며, Taco 테이블의 각 행(row)에 대해 하나 이상의 행(타코를 식자재와 연관시키는)을 포함한다(하나의 타코에는 하나 이상의 식자재가 포함될 수 있다).
- **Taco_Order**: 주문 정보를 저장한다.
- **Taco_Order_Tacos**: Taco_Order와 Taco 테이블 간의 관계를 나타내며, Taco_Order 테이블의 각 행에 대해 하나 이상의 행(주문을 타코와 연관시키는)을 포함한다(한 건의 주문에는 하나 이상의 타코가 포함될 수 있다.)

다음은 위의 테이블들을 생성하는 SQL을 보여준다.

```sql
create table if not exists Ingredient (
    id varchar(4) not null,
    name varchar(25) not null,
    type varchar(10) not null
);

create table if not exists Taco (
    id identity,
    name varchar(50) not null,
    createdAt timestamp not null
);

create table if not exists Taco_Ingredients (
    taco bigint not null,
    ingredient varchar(4) not null
);

alter table Taco_Ingredients
    and foreign key (taco) references Taco(id);
alter table Taco_Ingredients
    and foreign key (ingredent) references Ingredient(id);

create table if not exists Taco_Order (
	id identity,
    deliveryName varchar(50) not null,
    deliveryStreet varchar(50) not null,
    deliveryCity varchar(50) not null,
    deliveryState varchar(2) not null,
    deliveryZip varchar(10) not null,
    ccNumber varchar(16) not null,
    ccExpiration varchar(5) not null,
    ccCVV varchar(3) not null,
    placedAt timestamp not null
);

create table if not exists Taco_Order_Tacos (
	tacoOrder bigint not null,
    taco bigint not null
);

alter table Taco_Order_Tacos
    and foreign key (tacoOrder) references Taco_Order(id);
alter table Taco_Order_Tacos
	and foreign key (taco) references Taco(id);
```

위의 스키마는 schema.sql 이라는 이름의 파일로 애플리케이션 classpath 루트 경로 안에 작성한다. 그러면 애플리케이션이 시작될 때 사용 중인 데이터베이스에서 schema.sql 파일의 SQL이 자동으로 실행된다. 여기 프로젝트에서는 위의 SQL을 schema.sql 이름의 파일로 src/main/resources 폴더에 저장하였다.

한편 우리는 식자재 데이터를 데이터베이스에 미리 저장해야 한다. 다행히 스프링 부트는 애플리케이션이 시작될 때 data.sql이라는 이름의 파일도 실행한다. (앞의 schema.sql처럼 이 파일도 src/main/resources 폴더에 저장한다). 따라서 다음과 같이 SQL insert 명령을 사용하여 식자재 데이터를 미리 데이터베이스에 추가할 수 있다.

```sql
delete from Taco_Order_Tacos;
delete from Taco_Ingredients;
delete from Taco;
delete from Taco_Order;

delete from Ingredient;
insert into Ingredient (id, name, type)
                values ('FLTO', 'Flour Tortilla', 'WRAP');
insert into Ingredient (id, name, type)
                values ('COTO', 'Corn Tortilla', 'WRAP');
insert into Ingredient (id, name, type)
                values ('GRBF', 'Ground Beef', 'PROTEIN');
insert into Ingredient (id, name, type)
                values ('CARN', 'Carnitas', 'PROTEIN');
insert into Ingredient (id, name, type)
                values ('TMTO', 'Diced Tomatoes', 'VEGGIES');
insert into Ingredient (id, name, type)
                values ('LETC', 'Lettuce', 'VEGGIES');
insert into Ingredient (id, name, type)
                values ('CHED', 'Cheddar', 'CHEESE');
insert into Ingredient (id, name, type)
                values ('JACK', 'Monterrey Jack', 'CHEESE');
insert into Ingredient (id, name, type)
                values ('SLSA', 'Salsa', 'SAUCE');
insert into Ingredient (id, name, type)
                values ('SRCR', 'Sour Cream', 'SAUCE');
```

 ## 3.1.4 타코와 주문 데이터 추가하기(p87)

지금까지 JdbcTemplate을 사용하여 데이터베이스에 데이터를 저장하는 방법을 전반적으로 알아보았다. JdbcIngredientRepository의 save() 메서드에서는 JdbcTemplate의 update() 메서드를 사용하여 Ingredient 객체를 데이터베이스 데이터로 저장한다.

더 나아가 데이터를 저장할 때  JdbcIngredientRepository에서 했던 것보다 더 많은 처리가 필요할 수 있다. JdbcTemplate을 사용하여 데이터를 저장하는 방법은 두 가지가 있다.

- 직접 update() 메서드를 사용한다.
- SimpleJdbcInsert 래퍼(wrapper) 클래스를 사용한다.

Ingredient 객체를 저장할 때보다 퍼시스턴스 처리가 더 복잡할 때 어덯게 update() 메서드를 사용하는지 알아보자.
